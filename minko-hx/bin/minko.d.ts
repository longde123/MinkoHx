// Generated by Haxe TypeScript Declaration Generator :)

export namespace glm {
	/**
	 * Utility functions for 3D math
	 */
	class GLM{
		private constructor();
		/**
		 * Minimum absolute value difference of floats before they are considered equal
		 */
		static EPSILON: number;
		/**
		 * Utility for linearly interpolating between two values
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @return Float
		 */
		static lerp(a: number, b: number, t: number): number ;
		/**
		 * Constructs a 3D translation matrix
		 * @param translation How far to move in each of the directions
		 * @param dest Where the result will be stored
		 * @return Mat4
		 */
		static translate(translation: glm.Vec3Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs a 3D rotation matrix
		 * @param rotation The quaternion to use as rotation
		 * @param dest Where the result will be stored
		 * @return Mat4
		 */
		static rotate(rotation: glm.QuatBase, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs a 3D scale matrix
		 * @param amount How much to scale by in each of the three directions
		 * @param dest Where the result will be stored
		 * @return Mat4
		 */
		static scale(amount: glm.Vec3Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs a complete transformation matrix from translation, rotation, and scale components.
		 * It should be a fair bit faster than constructing each on their own and multiplying together.
		 * @param translation The translation vector
		 * @param rotation The rotation quaternion
		 * @param scale The scale vector
		 * @param dest Where to store the result
		 * @return Mat4
		 */
		static transform(translation: glm.Vec3Base, rotation: glm.QuatBase, scale: glm.Vec3Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs a lookat matrix to position a view matrix at `eye`, looking at `centre`, with `up` orienting the view
		 * @param eye Where the viewer is located
		 * @param centre Where the viewer is looking at
		 * @param up A vector pointing `up` for the view
		 * @param dest Where to store the result
		 * @return Mat4
		 */
		static lookAt(eye: glm.Vec3Base, centre: glm.Vec3Base, up: glm.Vec3Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs a perspective projection matrix
		 * @see https://github.com/toji/gl-matrix/blob/7fc31d5d292fb65b10aa98186b218a0bdef3a207/src/gl-matrix/mat4.js#L1241-L1271
		 * @param fovy The vertical field of view in radians
		 * @param aspectRatio The aspect ratio of the view
		 * @param near The near clipping plane
		 * @param far The far clipping plane
		 * @param dest Where to store the result
		 * @return Mat4
		 */
		static perspective(fovy: number, aspectRatio: number, near: number, far: number, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs an orthographic projection matrix
		 * @param left
		 * @param right
		 * @param bottom
		 * @param top
		 * @param near
		 * @param far
		 * @param dest Where to store the result
		 * @return Mat4
		 */
		static orthographic(left: number, right: number, bottom: number, top: number, near: number, far: number, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Constructs an orthographic projection matrix
		 * @see https://github.com/toji/gl-matrix/blob/7fc31d5d292fb65b10aa98186b218a0bdef3a207/src/gl-matrix/mat4.js#L1206-L1239
		 * @param left
		 * @param right
		 * @param bottom
		 * @param top
		 * @param near
		 * @param far
		 * @param dest Where to store the result
		 * @return Mat4
		 */
		static frustum(left: number, right: number, bottom: number, top: number, near: number, far: number, dest: glm.Mat4Base): glm.Mat4Base ;
	}
}

export namespace glm {
	class Mat2Base{
		constructor();
		_00: number;
		_10: number;
		_01: number;
		_11: number;
	}
}

export namespace glm {
	class Mat2Util{
		private constructor();
		static _new(_r0c0: number, _r0c1?: number, _r1c0?: number, _r1c1?: number): glm.Mat2Base ;
		/**
		 * Accessor for the element in row 0 and column 0
		 */
		static r0c0: number;
		/**
		 * Accessor for the element in row 1 and column 0
		 */
		static r1c0: number;
		/**
		 * Accessor for the element in row 0 and column 1
		 */
		static r0c1: number;
		/**
		 * Accessor for the element in row 1 and column 1
		 */
		static r1c1: number;
		/**
		 * Read an element using a column-major index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Mat2Base, key: number): number ;
		/**
		 * Write to an element using a column-major index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Mat2Base, key: number, value: number): number ;
		/**
		 * Tests if two matrices are equal on an element-by-element basis
		 * @param m the other matrix to check
		 * @return Bool
		 */
		static equals(this1: glm.Mat2Base, b: glm.Mat2Base): boolean ;
		/**
		 * Gets a string representation of the matrix
		 * @return String
		 */
		static toString(this1: glm.Mat2Base): string ;
		/**
		 * Fill `dest` with an identity matrix
		 * @param dest the matrix to fill out
		 * @return Mat2
		 */
		static identity(dest: glm.Mat2Base): glm.Mat2Base ;
		/**
		 * Copies one matrix into another
		 * @param src The matrix to copy from
		 * @param dest The matrix to copy into
		 * @return Mat2
		 */
		static copy(src: glm.Mat2Base, dest: glm.Mat2Base): glm.Mat2Base ;
		/**
		 * Transposes a matrix
		 * @param src The matrix to transpose
		 * @param dest The destination matrix. Call with `src == dest` to modify `src` in place
		 * @return Mat2
		 */
		static transpose(src: glm.Mat2Base, dest: glm.Mat2Base): glm.Mat2Base ;
		/**
		 * Calculates the determinant of the matrix
		 * @param src The matrix to calculate the determinant of
		 * @return Float
		 */
		static determinant(src: glm.Mat2Base): number ;
		/**
		 * Inverts the `src` matrix, storing the result in `dest`. If `src == dest`, modifies `src` in place.
		 * @param src The source matrix
		 * @param dest The matrix to store the result in
		 * @return Mat2
		 */
		static invert(src: glm.Mat2Base, dest: glm.Mat2Base): glm.Mat2Base ;
		/**
		 * Multiplies two matrices together, storing the result in `dest`. Caches `a` and `b` so `a == dest` and `b == dest` are valid.
		 * @param a The left-hand matrix
		 * @param b The right-hand matrix
		 * @param dest The matrix to store the result in
		 * @return Mat2
		 */
		static multMat(a: glm.Mat2Base, b: glm.Mat2Base, dest: glm.Mat2Base): glm.Mat2Base ;
		/**
		 * Multiplies a vector `v` by a matrix `m`, storing the result in `dest`. Caches so `v == dest` is valid.
		 * @param m The transforming matrix
		 * @param v The vector to multiply with
		 * @param dest The resulting vector
		 * @return Vec4
		 */
		static multVec(m: glm.Mat2Base, v: glm.Vec2Base, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Construct a Mat2 from an array of floats in column-major order
		 * @param arr an array with 16 elements
		 * @return Mat2
		 */
		static fromFloatArray(arr: number[]): glm.Mat2Base ;
		/**
		 * Cast the matrix in an array of floats, in column-major order
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Mat2Base): number[] ;
	}
}

export namespace glm {
	class Mat3Base{
		constructor();
		_00: number;
		_10: number;
		_20: number;
		_01: number;
		_11: number;
		_21: number;
		_02: number;
		_12: number;
		_22: number;
	}
}

export namespace glm {
	class Mat3Util{
		private constructor();
		static _new(_r0c0: number, _r0c1?: number, _r0c2?: number, _r1c0?: number, _r1c1?: number, _r1c2?: number, _r2c0?: number, _r2c1?: number, _r2c2?: number): glm.Mat3Base ;
		/**
		 * Accessor for the element in row 0 and column 0
		 */
		static r0c0: number;
		/**
		 * Accessor for the element in row 1 and column 0
		 */
		static r1c0: number;
		/**
		 * Accessor for the element in row 2 and column 0
		 */
		static r2c0: number;
		/**
		 * Accessor for the element in row 0 and column 1
		 */
		static r0c1: number;
		/**
		 * Accessor for the element in row 1 and column 1
		 */
		static r1c1: number;
		/**
		 * Accessor for the element in row 2 and column 1
		 */
		static r2c1: number;
		/**
		 * Accessor for the element in row 0 and column 2
		 */
		static r0c2: number;
		/**
		 * Accessor for the element in row 1 and column 2
		 */
		static r1c2: number;
		/**
		 * Accessor for the element in row 2 and column 2
		 */
		static r2c2: number;
		/**
		 * Read an element using a column-major index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Mat3Base, key: number): number ;
		/**
		 * Write to an element using a column-major index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Mat3Base, key: number, value: number): number ;
		/**
		 * Tests if two matrices are equal on an element-by-element basis
		 * @param m the other matrix to check
		 * @return Bool
		 */
		static equals(this1: glm.Mat3Base, b: glm.Mat3Base): boolean ;
		/**
		 * Gets a string representation of the matrix
		 * @return String
		 */
		static toString(this1: glm.Mat3Base): string ;
		/**
		 * Fill `dest` with an identity matrix
		 * @param dest the matrix to fill out
		 * @return Mat3
		 */
		static identity(dest: glm.Mat3Base): glm.Mat3Base ;
		/**
		 * Copies one matrix into another
		 * @param src The matrix to copy from
		 * @param dest The matrix to copy into
		 * @return Mat3
		 */
		static copy(src: glm.Mat3Base, dest: glm.Mat3Base): glm.Mat3Base ;
		/**
		 * Transposes a matrix
		 * @param src The matrix to transpose
		 * @param dest The destination matrix. Call with `src == dest` to modify `src` in place
		 * @return Mat3
		 */
		static transpose(src: glm.Mat3Base, dest: glm.Mat3Base): glm.Mat3Base ;
		/**
		 * Calculates the determinant of the matrix
		 * @param src The matrix to calculate the determinant of
		 * @return Float
		 */
		static determinant(src: glm.Mat3Base): number ;
		/**
		 * Inverts the `src` matrix, storing the result in `dest`. If `src == dest`, modifies `src` in place.
		 * @param src The source matrix
		 * @param dest The matrix to store the result in
		 * @return Mat3
		 */
		static invert(src: glm.Mat3Base, dest: glm.Mat3Base): glm.Mat3Base ;
		/**
		 * Multiplies two matrices together, storing the result in `dest`. Caches `a` and `b` so `a == dest` and `b == dest` are valid.
		 * @param a The left-hand matrix
		 * @param b The right-hand matrix
		 * @param dest The matrix to store the result in
		 * @return Mat3
		 */
		static multMat(a: glm.Mat3Base, b: glm.Mat3Base, dest: glm.Mat3Base): glm.Mat3Base ;
		/**
		 * Multiplies a vector `v` by a matrix `m`, storing the result in `dest`. Caches so `v == dest` is valid.
		 * @param m The transforming matrix
		 * @param v The vector to multiply with
		 * @param dest The resulting vector
		 * @return Vec4
		 */
		static multVec(m: glm.Mat3Base, v: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Construct a Mat3 from an array of floats in column-major order
		 * @param arr an array with 16 elements
		 * @return Mat3
		 */
		static fromFloatArray(arr: number[]): glm.Mat3Base ;
		/**
		 * Cast the matrix in an array of floats, in column-major order
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Mat3Base): number[] ;
	}
}

export namespace glm {
	class Mat4Base{
		constructor();
		_00: number;
		_10: number;
		_20: number;
		_30: number;
		_01: number;
		_11: number;
		_21: number;
		_31: number;
		_02: number;
		_12: number;
		_22: number;
		_32: number;
		_03: number;
		_13: number;
		_23: number;
		_33: number;
	}
}

export namespace glm {
	class Mat4Util{
		private constructor();
		static _new(_r0c0: number, _r0c1?: number, _r0c2?: number, _r0c3?: number, _r1c0?: number, _r1c1?: number, _r1c2?: number, _r1c3?: number, _r2c0?: number, _r2c1?: number, _r2c2?: number, _r2c3?: number, _r3c0?: number, _r3c1?: number, _r3c2?: number, _r3c3?: number): glm.Mat4Base ;
		/**
		 * Accessor for the element in row 0 and column 0
		 */
		static r0c0: number;
		/**
		 * Accessor for the element in row 1 and column 0
		 */
		static r1c0: number;
		/**
		 * Accessor for the element in row 2 and column 0
		 */
		static r2c0: number;
		/**
		 * Accessor for the element in row 3 and column 0
		 */
		static r3c0: number;
		/**
		 * Accessor for the element in row 0 and column 1
		 */
		static r0c1: number;
		/**
		 * Accessor for the element in row 1 and column 1
		 */
		static r1c1: number;
		/**
		 * Accessor for the element in row 2 and column 1
		 */
		static r2c1: number;
		/**
		 * Accessor for the element in row 3 and column 1
		 */
		static r3c1: number;
		/**
		 * Accessor for the element in row 0 and column 2
		 */
		static r0c2: number;
		/**
		 * Accessor for the element in row 1 and column 2
		 */
		static r1c2: number;
		/**
		 * Accessor for the element in row 2 and column 2
		 */
		static r2c2: number;
		/**
		 * Accessor for the element in row 3 and column 2
		 */
		static r3c2: number;
		/**
		 * Accessor for the element in row 0 and column 3
		 */
		static r0c3: number;
		/**
		 * Accessor for the element in row 1 and column 3
		 */
		static r1c3: number;
		/**
		 * Accessor for the element in row 2 and column 3
		 */
		static r2c3: number;
		/**
		 * Accessor for the element in row 3 and column 3
		 */
		static r3c3: number;
		/**
		 * Read an element using a column-major index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Mat4Base, key: number): number ;
		/**
		 * Write to an element using a column-major index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Mat4Base, key: number, value: number): number ;
		/**
		 * Tests if two matrices are equal on an element-by-element basis
		 * @param m the other matrix to check
		 * @return Bool
		 */
		static equals(this1: glm.Mat4Base, b: glm.Mat4Base): boolean ;
		/**
		 * Gets a string representation of the matrix
		 * @return String
		 */
		static toString(this1: glm.Mat4Base): string ;
		/**
		 * Fill `dest` with an identity matrix
		 * @param dest the matrix to fill out
		 * @return Mat4
		 */
		static identity(dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Copies one matrix into another
		 * @param src The matrix to copy from
		 * @param dest The matrix to copy into
		 * @return Mat4
		 */
		static copy(src: glm.Mat4Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Transposes a matrix
		 * @param src The matrix to transpose
		 * @param dest The destination matrix. Call with `src == dest` to modify `src` in place
		 * @return Mat4
		 */
		static transpose(src: glm.Mat4Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Calculates the determinant of the matrix
		 * @param src The matrix to calculate the determinant of
		 * @return Float
		 */
		static determinant(src: glm.Mat4Base): number ;
		/**
		 * Inverts the `src` matrix, storing the result in `dest`. If `src == dest`, modifies `src` in place.
		 * @param src The source matrix
		 * @param dest The matrix to store the result in
		 * @return Mat4
		 */
		static invert(src: glm.Mat4Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Multiplies two matrices together, storing the result in `dest`. Caches `a` and `b` so `a == dest` and `b == dest` are valid.
		 * @param a The left-hand matrix
		 * @param b The right-hand matrix
		 * @param dest The matrix to store the result in
		 * @return Mat4
		 */
		static multMat(a: glm.Mat4Base, b: glm.Mat4Base, dest: glm.Mat4Base): glm.Mat4Base ;
		/**
		 * Multiplies a vector `v` by a matrix `m`, storing the result in `dest`. Caches so `v == dest` is valid.
		 * @param m The transforming matrix
		 * @param v The vector to multiply with
		 * @param dest The resulting vector
		 * @return Vec4
		 */
		static multVec(m: glm.Mat4Base, v: glm.Vec4Base, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Construct a Mat4 from an array of floats in column-major order
		 * @param arr an array with 16 elements
		 * @return Mat4
		 */
		static fromFloatArray(arr: number[]): glm.Mat4Base ;
		/**
		 * Cast the matrix in an array of floats, in column-major order
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Mat4Base): number[] ;
	}
}

export namespace glm {
	class QuatBase{
		constructor();
		x: number;
		y: number;
		z: number;
		w: number;
	}
}

export namespace glm {
	class QuatUtil{
		private constructor();
		/**
		 * Accessor for the first element of the quaternion
		 */
		static x: number;
		/**
		 * Accessor for the second element of the quaternion
		 */
		static y: number;
		/**
		 * Accessor for the third element of the quaternion
		 */
		static z: number;
		/**
		 * Accessor for the fourth element of the quaternion
		 */
		static w: number;
		/**
		 * Read an element using an index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.QuatBase, key: number): number ;
		/**
		 * Write to an element using an index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.QuatBase, key: number, value: number): number ;
		static _new(x: number, y?: number, z?: number, w?: number): glm.QuatBase ;
		/**
		 * Checks if `this == v` on an element-by-element basis
		 * @param v The quaternion to check against
		 * @return Bool
		 */
		static equals(this1: glm.QuatBase, b: glm.QuatBase): boolean ;
		/**
		 * Creates a string reprentation of `this`
		 * @return String
		 */
		static toString(this1: glm.QuatBase): string ;
		/**
		 * Calculates the square of the magnitude of the quaternion, to save calculation time if the actual magnitude isn't needed
		 * @return Float
		 */
		static lengthSquared(this1: glm.QuatBase): number ;
		/**
		 * Calculates the magnitude of the quaternion
		 * @return Float
		 */
		static length(this1: glm.QuatBase): number ;
		/**
		 * Normalizes `q` such that `q.length() == 1`, and stores the result in `dest`
		 * @param q
		 * @param dest
		 * @return Quat
		 */
		static normalize(q: glm.QuatBase, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Calculates the dot product of two quaternions
		 * @param a
		 * @param b
		 * @return Float
		 */
		static dot(a: glm.QuatBase, b: glm.QuatBase): number ;
		/**
		 * Fills `dest` with an identity quat
		 * @param dest
		 * @return Quat
		 */
		static identity(dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Copies one quaternion into another
		 * @param src The quaternion to copy from
		 * @param dest The quaternion to copy into
		 * @return Quat
		 */
		static copy(src: glm.QuatBase, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Creates a quaternion from an axis and an angle (in radians).
		 * @param axis The axis to rotate about. Must be normalized first!
		 * @param angle The angle to rotate by, in radians
		 * @param dest Where to store the result
		 * @return Quat
		 */
		static axisAngle(axis: glm.Vec3Base, angle: number, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Multiplies two quaternions together, both inputs are cached so either can be used as the destination
		 * @param a The left-hand side quaternion
		 * @param b The right-hand side quaternion
		 * @param dest Where to store the result
		 * @return Quat
		 */
		static multiplyQuats(a: glm.QuatBase, b: glm.QuatBase, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Scales `a` by `s`, storing the result in `dest`
		 * @param a
		 * @param s
		 * @param dest
		 * @return Quat
		 */
		static multiplyScalar(a: glm.QuatBase, s: number, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Linearly interpolates between `a` and `b`. Note: you probably want `slerp`!
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @param dest The vector to store the result in
		 * @return Quat
		 */
		static lerp(a: glm.QuatBase, b: glm.QuatBase, t: number, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Spherical-linear interpolates between `a` and `b`
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @param dest The vector to store the result in
		 * @return Quat
		 */
		static slerp(a: glm.QuatBase, b: glm.QuatBase, t: number, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Inverts the quaterion `q`, storing the result in `dest`
		 * @param q
		 * @param dest
		 * @return Quat
		 */
		static invert(q: glm.QuatBase, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Calculates the conjugate of `q`, storing the result in `dest`
		 * @param q
		 * @param dest
		 * @return Quat
		 */
		static conjugate(q: glm.QuatBase, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Constructs a quaternion from roll, pitch, and yaw (x, y, and z axes)
		 * @param x The angle to rotate around x
		 * @param y The angle to rotate around y
		 * @param z The angle to rotate around z
		 * @param dest Where to store the result
		 * @return Quat
		 */
		static fromEuler(x: number, y: number, z: number, dest: glm.QuatBase): glm.QuatBase ;
		/**
		 * Construct a Quat from an array of floats
		 * @param arr an array with 4 elements, corresponding to x, y, z, w
		 * @return Quat
		 */
		static fromFloatArray(arr: number[]): glm.QuatBase ;
		/**
		 * Converts this into a 4-element array of floats
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.QuatBase): number[] ;
	}
}

export namespace glm {
	class Vec2Base{
		constructor();
		x: number;
		y: number;
	}
}

export namespace glm {
	class Vec2Util{
		private constructor();
		/**
		 * Accessor for the first element of the vector
		 */
		static x: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static y: number;
		/**
		 * Accessor for the first element of the vector
		 */
		static i: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static j: number;
		/**
		 * Read an element using an index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Vec2Base, key: number): number ;
		/**
		 * Write to an element using an index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Vec2Base, key: number, value: number): number ;
		static _new(x: number, y?: number): glm.Vec2Base ;
		/**
		 * Checks if `this == v` on an element-by-element basis
		 * @param v - The vector to check against
		 * @return Bool
		 */
		static equals(this1: glm.Vec2Base, b: glm.Vec2Base): boolean ;
		/**
		 * Creates a string reprentation of `this`
		 * @return String
		 */
		static toString(this1: glm.Vec2Base): string ;
		/**
		 * Calculates the square of the magnitude of the vector, to save calculation time if the actual magnitude isn't needed
		 * @return Float
		 */
		static lengthSquared(this1: glm.Vec2Base): number ;
		/**
		 * Calculates the magnitude of the vector
		 * @return Float
		 */
		static length(this1: glm.Vec2Base): number ;
		/**
		 * Copies one vector into another
		 * @param src The vector to copy from
		 * @param dest The vector to copy into
		 * @return Vec2
		 */
		static copy(src: glm.Vec2Base, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Utility for setting an entire vector at once
		 * @param dest The vector to set values into
		 * @param x
		 * @param y
		 * @return Vec2
		 */
		static setComponents(dest: glm.Vec2Base, x?: number, y?: number): glm.Vec2Base ;
		/**
		 * Adds two vectors on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec2
		 */
		static addVec(a: glm.Vec2Base, b: glm.Vec2Base, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Subtracts `b` from `a` on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec2
		 */
		static subtractVec(a: glm.Vec2Base, b: glm.Vec2Base, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Adds a scalar to a vector
		 * @param a The vector to add a scalar to
		 * @param s A scalar to add
		 * @param dest The vector to store the result in
		 * @return Vec2
		 */
		static addScalar(a: glm.Vec2Base, s: number, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Multiplies the elements of `a` by `s`, storing the result in `dest`
		 * @param a
		 * @param s
		 * @param dest
		 * @return Vec2
		 */
		static multiplyScalar(a: glm.Vec2Base, s: number, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Calculates the square of the distance between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distanceSquared(a: glm.Vec2Base, b: glm.Vec2Base): number ;
		/**
		 * Calculates the distance (magnitude) between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distance(a: glm.Vec2Base, b: glm.Vec2Base): number ;
		/**
		 * Calculates the dot product of two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static dot(a: glm.Vec2Base, b: glm.Vec2Base): number ;
		/**
		 * Calculates the cross product of `a` and `b`
		 * @param a The left-hand side vector to cross
		 * @param b The right-hand side vector to cross
		 * @param dest Where to store the result
		 * @return Vec3 `dest`
		 */
		static cross(a: glm.Vec2Base, b: glm.Vec2Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Normalizes `v` such that `v.length() == 1`, and stores the result in `dest`
		 * @param v
		 * @param dest
		 * @return Vec2
		 */
		static normalize(v: glm.Vec2Base, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Linearly interpolates between `a` and `b`.
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @param dest The vector to store the result in
		 * @return Vec2
		 */
		static lerp(a: glm.Vec2Base, b: glm.Vec2Base, t: number, dest: glm.Vec2Base): glm.Vec2Base ;
		/**
		 * Construct a Vec2 from an array of floats
		 * @param arr an array with 2 elements, corresponding to x, y
		 * @return Vec2
		 */
		static fromFloatArray(arr: number[]): glm.Vec2Base ;
		/**
		 * Converts this into a 2-element array of floats
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Vec2Base): number[] ;
	}
}

export namespace glm {
	class Vec3Base{
		constructor();
		x: number;
		y: number;
		z: number;
	}
}

export namespace glm {
	class Vec3Util{
		private constructor();
		/**
		 * Accessor for the first element of the vector
		 */
		static x: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static y: number;
		/**
		 * Accessor for the third element of the vector
		 */
		static z: number;
		/**
		 * Accessor for the first element of the vector
		 */
		static r: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static g: number;
		/**
		 * Accessor for the third element of the vector
		 */
		static b: number;
		/**
		 * Read an element using an index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Vec3Base, key: number): number ;
		/**
		 * Write to an element using an index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Vec3Base, key: number, value: number): number ;
		static _new(x: number, y?: number, z?: number): glm.Vec3Base ;
		/**
		 * Checks if `this == v` on an element-by-element basis
		 * @param v - The vector to check against
		 * @return Bool
		 */
		static equals(this1: glm.Vec3Base, b: glm.Vec3Base): boolean ;
		/**
		 * Creates a string reprentation of `this`
		 * @return String
		 */
		static toString(this1: glm.Vec3Base): string ;
		/**
		 * Calculates the square of the magnitude of the vector, to save calculation time if the actual magnitude isn't needed
		 * @return Float
		 */
		static lengthSquared(this1: glm.Vec3Base): number ;
		/**
		 * Calculates the magnitude of the vector
		 * @return Float
		 */
		static length(this1: glm.Vec3Base): number ;
		/**
		 * Copies one vector into another
		 * @param src The vector to copy from
		 * @param dest The vector to copy into
		 * @return Vec3
		 */
		static copy(src: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Utility for setting an entire vector at once
		 * @param dest The vector to set values into
		 * @param x
		 * @param y
		 * @param z
		 * @return Vec3
		 */
		static setComponents(dest: glm.Vec3Base, x?: number, y?: number, z?: number): glm.Vec3Base ;
		/**
		 * Adds two vectors on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec3
		 */
		static addVec(a: glm.Vec3Base, b: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Subtracts `b` from `a` on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec3
		 */
		static subtractVec(a: glm.Vec3Base, b: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Adds a scalar to a vector
		 * @param a The vector to add a scalar to
		 * @param s A scalar to add
		 * @param dest The vector to store the result in
		 * @return Vec3
		 */
		static addScalar(a: glm.Vec3Base, s: number, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Multiplies the elements of `a` by `s`, storing the result in `dest`
		 * @param a
		 * @param s
		 * @param dest
		 * @return Vec3
		 */
		static multiplyScalar(a: glm.Vec3Base, s: number, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Calculates the square of the distance between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distanceSquared(a: glm.Vec3Base, b: glm.Vec3Base): number ;
		/**
		 * Calculates the distance (magnitude) between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distance(a: glm.Vec3Base, b: glm.Vec3Base): number ;
		/**
		 * Calculates the dot product of two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static dot(a: glm.Vec3Base, b: glm.Vec3Base): number ;
		/**
		 * Calculates the cross product of `a` and `b`
		 * @param a The left-hand side vector to cross
		 * @param b The right-hand side vector to cross
		 * @param dest Where to store the result
		 * @return Vec3 `dest`
		 */
		static cross(a: glm.Vec3Base, b: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Normalizes `v` such that `v.length() == 1`, and stores the result in `dest`
		 * @param v
		 * @param dest
		 * @return Vec3
		 */
		static normalize(v: glm.Vec3Base, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Linearly interpolates between `a` and `b`.
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @param dest The vector to store the result in
		 * @return Vec3
		 */
		static lerp(a: glm.Vec3Base, b: glm.Vec3Base, t: number, dest: glm.Vec3Base): glm.Vec3Base ;
		/**
		 * Construct a Vec3 from an array of floats
		 * @param arr an array with 3 elements, corresponding to x, y, z
		 * @return Vec3
		 */
		static fromFloatArray(arr: number[]): glm.Vec3Base ;
		/**
		 * Converts this into a 3-element array of floats
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Vec3Base): number[] ;
	}
}

export namespace glm {
	class Vec4Base{
		constructor();
		x: number;
		y: number;
		z: number;
		w: number;
	}
}

export namespace glm {
	class Vec4Util{
		private constructor();
		/**
		 * Accessor for the first element of the vector
		 */
		static x: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static y: number;
		/**
		 * Accessor for the third element of the vector
		 */
		static z: number;
		/**
		 * Accessor for the fourth element of the vector
		 */
		static w: number;
		/**
		 * Accessor for the first element of the vector
		 */
		static r: number;
		/**
		 * Accessor for the second element of the vector
		 */
		static g: number;
		/**
		 * Accessor for the third element of the vector
		 */
		static b: number;
		/**
		 * Accessor for the fourth element of the vector
		 */
		static a: number;
		/**
		 * Read an element using an index
		 * @param key the index to use
		 * @return Float
		 */
		static get(this1: glm.Vec4Base, key: number): number ;
		/**
		 * Write to an element using an index
		 * @param key the index to use
		 * @param value the value to set
		 * @return Float
		 */
		static set(this1: glm.Vec4Base, key: number, value: number): number ;
		static _new(x: number, y?: number, z?: number, w?: number): glm.Vec4Base ;
		/**
		 * Checks if `this == v` on an element-by-element basis
		 * @param v - The vector to check against
		 * @return Bool
		 */
		static equals(this1: glm.Vec4Base, b: glm.Vec4Base): boolean ;
		/**
		 * Creates a string reprentation of `this`
		 * @return String
		 */
		static toString(this1: glm.Vec4Base): string ;
		/**
		 * Calculates the square of the magnitude of the vector, to save calculation time if the actual magnitude isn't needed
		 * @return Float
		 */
		static lengthSquared(this1: glm.Vec4Base): number ;
		/**
		 * Calculates the magnitude of the vector
		 * @return Float
		 */
		static length(this1: glm.Vec4Base): number ;
		/**
		 * Copies one vector into another
		 * @param src The vector to copy from
		 * @param dest The vector to copy into
		 * @return Vec4
		 */
		static copy(src: glm.Vec4Base, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Utility for setting an entire vector at once
		 * @param dest The vector to set values into
		 * @param x
		 * @param y
		 * @param z
		 * @param w
		 * @return Vec4
		 */
		static setComponents(dest: glm.Vec4Base, x?: number, y?: number, z?: number, w?: number): glm.Vec4Base ;
		/**
		 * Adds two vectors on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec4
		 */
		static addVec(a: glm.Vec4Base, b: glm.Vec4Base, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Subtracts `b` from `a` on an element-by-element basis
		 * @param a
		 * @param b
		 * @param dest The vector to store the result in
		 * @return Vec4
		 */
		static subtractVec(a: glm.Vec4Base, b: glm.Vec4Base, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Adds a scalar to a vector
		 * @param a The vector to add a scalar to
		 * @param s A scalar to add
		 * @param dest The vector to store the result in
		 * @return Vec4
		 */
		static addScalar(a: glm.Vec4Base, s: number, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Multiplies the elements of `a` by `s`, storing the result in `dest`
		 * @param a
		 * @param s
		 * @param dest
		 * @return Vec4
		 */
		static multiplyScalar(a: glm.Vec4Base, s: number, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Calculates the square of the distance between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distanceSquared(a: glm.Vec4Base, b: glm.Vec4Base): number ;
		/**
		 * Calculates the distance (magnitude) between two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static distance(a: glm.Vec4Base, b: glm.Vec4Base): number ;
		/**
		 * Calculates the dot product of two vectors
		 * @param a
		 * @param b
		 * @return Float
		 */
		static dot(a: glm.Vec4Base, b: glm.Vec4Base): number ;
		/**
		 * Normalizes `v` such that `v.length() == 1`, and stores the result in `dest`
		 * @param v
		 * @param dest
		 * @return Vec4
		 */
		static normalize(v: glm.Vec4Base, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Linearly interpolates between `a` and `b`.
		 * @param a The value when `t == 0`
		 * @param b The value when `t == 1`
		 * @param t A value between `0` and `1`, not clamped by the function
		 * @param dest The vector to store the result in
		 * @return Vec4
		 */
		static lerp(a: glm.Vec4Base, b: glm.Vec4Base, t: number, dest: glm.Vec4Base): glm.Vec4Base ;
		/**
		 * Construct a Vec4 from an array of floats
		 * @param arr an array with 4 elements, corresponding to x, y, z, w
		 * @return Vec4
		 */
		static fromFloatArray(arr: number[]): glm.Vec4Base ;
		/**
		 * Converts this into a 4-element array of floats
		 * @return Array<Float>
		 */
		static toFloatArray(this1: glm.Vec4Base): number[] ;
	}
}

export namespace haxe {
	class IMap<K, V>{
		private constructor();
	}
}

export namespace haxe.io {
	class Bytes{
		private constructor(data: ArrayBuffer);
		readonly length: number;
		blit(pos: number, src: haxe.io.Bytes, srcpos: number, len: number): void ;
		getString(pos: number, len: number): string ;
		toString(): string ;
		static ofString(s: string): haxe.io.Bytes ;
		static ofData(b: ArrayBuffer): haxe.io.Bytes ;
	}
}

export namespace haxe.ds {
	class IntMap<T>{
		/**
		 * Creates a new IntMap.
		 */
		constructor();
		/**
		 * See `Map.remove`
		 */
		remove(key: number): boolean ;
		/**
		 * See `Map.keys`
		 */
		keys(): {hasNext: () => boolean, next: () => number} ;
		/**
		 * See `Map.iterator`
		 */
		iterator(): {hasNext: () => boolean, next: () => T} ;
	}
}

export namespace haxe.ds {
	class ObjectMap<K, V>{
		/**
		 * Creates a new ObjectMap.
		 */
		constructor();
		/**
		 * See `Map.set`
		 */
		set(key: K, value: V): void ;
		/**
		 * See `Map.remove`
		 */
		remove(key: K): boolean ;
		/**
		 * See `Map.keys`
		 */
		keys(): {hasNext: () => boolean, next: () => K} ;
		/**
		 * See `Map.iterator`
		 */
		iterator(): {hasNext: () => boolean, next: () => V} ;
	}
}

export namespace haxe.ds._StringMap {
	class StringMapIterator<T>{
		constructor(map: haxe.ds.StringMap<T>, keys: string[]);
		hasNext(): boolean ;
		next(): T ;
	}
}

export namespace haxe.ds {
	class StringMap<T>{
		/**
		 * Creates a new StringMap.
		 */
		constructor();
		/**
		 * See `Map.remove`
		 */
		remove(key: string): boolean ;
		/**
		 * See `Map.keys`
		 */
		keys(): {hasNext: () => boolean, next: () => string} ;
		/**
		 * See `Map.iterator`
		 */
		iterator(): {hasNext: () => boolean, next: () => T} ;
	}
}

export namespace minko {
	class AbstractBackend{
		constructor();
		initialize(canvas: minko.WebCanvas): void ;
		swapBuffers(canvas: minko.AbstractCanvas): void ;
		run(canvas: minko.AbstractCanvas): void ;
		wait(canvas: minko.AbstractCanvas, ms: number): void ;
		static create(): minko.AbstractBackend ;
	}
}

export namespace minko {
	class Flags{
		private constructor();
		static readonly FULLSCREEN: number;
		static readonly RESIZABLE: number;
		static readonly HIDDEN: number;
		static readonly CHROMELESS: number;
		static readonly STENCIL: number;
	}
}

export namespace minko {
	class AbstractCanvas{
		constructor(name: string, width: number, height: number, flags: number);
		readonly framerate: number;
		readonly active: boolean;
		x: number;
		y: number;
		width: number;
		height: number;
		readonly aspectRatio: number;
		readonly data: minko.data.Provider;
		readonly context: minko.render.AbstractContext;
		readonly mouse: minko.input.Mouse;
		readonly keyboard: minko.input.Keyboard;
		readonly touch: minko.input.Touch;
		readonly numJoysticks: number;
		readonly enterFrame: minko.signal.Signal3<minko.AbstractCanvas, number, number>;
		readonly resized: minko.signal.Signal3<minko.AbstractCanvas, number, number>;
		readonly joystickAdded: minko.signal.Signal2<minko.AbstractCanvas, minko.input.Joystick>;
		readonly joystickRemoved: minko.signal.Signal2<minko.AbstractCanvas, minko.input.Joystick>;
		readonly suspended: minko.signal.Signal<minko.AbstractCanvas>;
		readonly resumed: minko.signal.Signal<minko.AbstractCanvas>;
		getJoystickAxis(joystick: minko.input.Joystick, axis: number): number ;
		isWorkerRegistered(name: string): boolean ;
		registerWorker(name: string, cls: (arg0: string) => minko.async.Worker): void ;
		initialize(): void ;
		joystick(id: number): minko.input.Joystick ;
		createScene(): minko.scene.Node ;
		step(): void ;
		run(): void ;
		quit(): void ;
		getWorker(name: string): minko.async.Worker ;
		swapBuffers(): void ;
		resetInputs(): void ;
		static defaultCanvas: minko.AbstractCanvas;
	}
}

export namespace minko {
	class Canvas extends minko.AbstractCanvas{
		constructor(name: string, width: number, height: number, flags: number);
	}
}

export namespace minko {
	class CloneOption{
		private constructor();
		static readonly SHALLOW: number;
		static readonly DEEP: number;
	}
}

export namespace minko {
	class Tuple<T, K>{
		constructor(f: T, s: K);
		first: T;
		second: K;
	}
}

export namespace minko {
	class Tuple3<A, B, C>{
		constructor(f: A, s: B, t: C);
		first: A;
		second: B;
		thiree: C;
	}
}

export namespace minko {
	class Tuple4<A, B, C, D>{
		constructor(a: A, b: B, c: C, d: D);
		first: A;
		second: B;
		thiree: C;
		four: D;
	}
}

export namespace minko {
	class Tuple5<A, B, C, D, E>{
		constructor(a: A, b: B, c: C, d: D, e: E);
		first: A;
		second: B;
		thiree: C;
		four: D;
		five: E;
	}
}

export namespace minko {
	class Tuple6<A, B, C, D, E, F>{
		constructor(a: A, b: B, c: C, d: D, e: E, f: F);
		first: A;
		second: B;
		thiree: C;
		four: D;
		five: E;
		six: F;
	}
}

export namespace minko {
	class Uuid{
		private constructor();
		static getUuid(): string ;
	}
}

export namespace minko {
	class Has_uuid{
		constructor();
		uuid: string;
	}
}

export namespace minko {
	class Enable_uuid extends minko.Has_uuid{
		constructor();
		enable_uuid(): void ;
	}
}

export namespace minko {
	class WebBackend extends minko.AbstractBackend{
		constructor();
		currentCanvas: minko.AbstractCanvas;
		canvasHidden: number;
		initialize(canvas: minko.WebCanvas): void ;
		swapBuffers(canvas: minko.AbstractCanvas): void ;
		run(canvas: minko.AbstractCanvas): void ;
		wait(canvas: minko.AbstractCanvas, ms: number): void ;
		emscriptenMainLoop(): void ;
		static create(): minko.WebBackend ;
		static getCurrentLoop(): () => void ;
		static setLoop(f: () => void): void ;
	}
}

export namespace minko {
	class WebCanvas extends minko.Canvas{
		constructor(name: string, width: number, height: number, flags: number);
		initialize(): void ;
		initializeInputs(): void ;
		initializeWindow(): void ;
		initializeContext(): void ;
		step(): void ;
		static create(name: string, width?: number, height?: number, flags?: number): minko.WebCanvas ;
	}
}

export namespace minko.animation {
	class AbstractTimeline{
		constructor(propertyName: string, duration: number);
		clone(): minko.animation.AbstractTimeline ;
		propertyName: string;
		duration: number;
		isLocked: boolean;
		update(time: number, data: minko.data.Store, skipPropertyNameFormatting?: boolean): void ;
		dispose(): void ;
	}
}

export namespace minko.animation {
	class TimelineLookup{
		constructor();
		timetable: number;
		mat4: glm.Mat4Base;
		static interpolate(thisMat: glm.Mat4Base, toMat: glm.Mat4Base, percent: number): glm.Mat4Base ;
		static getTimeInRange(time: number, duration: number): number ;
		static getIndexForTime(time: number, timetable: minko.animation.TimelineLookup[]): number ;
	}
}

export namespace minko.animation {
	class Matrix4x4Timeline extends minko.animation.AbstractTimeline{
		constructor(propertyName: string, duration: number, timetable?: number[], matrices?: glm.Mat4Base[], interpolate?: boolean);
		clone(): minko.animation.Matrix4x4Timeline ;
		readonly matrices: minko.animation.TimelineLookup[];
		readonly interpolate: boolean;
		update(time: number, data: minko.data.Store, skipPropertyNameFormatting?: boolean): void ;
		interpolateTime(time: number): glm.Mat4Base ;
		dispose(): void ;
		static create(propertyName: string, duration: number, timetable?: number[], matrices?: glm.Mat4Base[], interpolate?: boolean): minko.animation.Matrix4x4Timeline ;
		static createbyMatrix4x4Timeline(matrix: minko.animation.Matrix4x4Timeline): minko.animation.Matrix4x4Timeline ;
	}
}

export namespace minko.async {
	class Worker{
		constructor(name: string);
		start(input: haxe.io.Bytes): void ;
		readonly message: minko.signal.Signal2<minko.async.Worker, minko.async.Message>;
		post(message: minko.async.Message): void ;
		run(input: haxe.io.Bytes): void ;
		poll(): void ;
		dispose(): void ;
	}
}

export namespace minko.async {
	class Message{
		constructor();
		type: string;
		data: any;
	}
}

export namespace minko.async {
	class WorkerImpl{
		constructor(that: minko.async.Worker, name: string);
		start(input: haxe.io.Bytes): void ;
		poll(): void ;
		post(message: minko.async.Message): void ;
		readonly message: minko.signal.Signal2<minko.async.Worker, minko.async.Message>;
		dispose(): void ;
	}
}

export namespace minko.component {
	class AbstractComponent extends minko.Enable_uuid{
		constructor(layoutMask: number);
		dispose(): void ;
		clone(option: number): minko.component.AbstractComponent ;
		target: minko.scene.Node;
		layoutMask: number;
		readonly layoutMaskChanged: minko.signal.Signal<minko.component.AbstractComponent>;
		targetAdded(node: minko.scene.Node): void ;
		targetRemoved(node: minko.scene.Node): void ;
		rebindDependencies(componentsMap: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, option: number): void ;
	}
}

export namespace minko.component {
	class AbstractScript extends minko.component.AbstractComponent{
		constructor();
		enabled: boolean;
		readonly time: number;
		readonly deltaTime: number;
		start(target: minko.scene.Node): void ;
		update(target: minko.scene.Node): void ;
		end(target: minko.scene.Node): void ;
		stop(target: minko.scene.Node): void ;
		readonly ready: boolean;
		readonly priority: number;
		targetAdded(target: minko.scene.Node): void ;
		addedOrRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		componentAddedHandler(nod: minko.scene.Node, target: minko.scene.Node, component: minko.component.AbstractComponent): void ;
		componentRemovedHandler(nod: minko.scene.Node, target: minko.scene.Node, component: minko.component.AbstractComponent): void ;
		frameBeginHandler(sceneManager: minko.component.SceneManager, time: number, deltaTime: number): void ;
		frameEndHandler(sceneManager: minko.component.SceneManager, time: number, deltaTime: number): void ;
	}
}

export namespace minko.audio {
	class PositionalSound extends minko.component.AbstractScript{
		constructor(channel: minko.audio.SoundChannel, camera: minko.scene.Node);
		audibilityCurve: (arg0: number) => number;
		static create(channel: minko.audio.SoundChannel, camera: minko.scene.Node): minko.audio.PositionalSound ;
	}
}

export namespace minko.audio {
	class Sound{
		constructor();
		dispose(): void ;
	}
}

export namespace minko.audio {
	class SoundChannel{
		constructor(sound: minko.audio.Sound);
		readonly complete: minko.signal.Signal<minko.audio.SoundChannel>;
		readonly sound: minko.audio.Sound;
		transform: minko.audio.SoundTransform;
		stop(): void ;
		readonly playing: boolean;
		dispose(): void ;
	}
}

export namespace minko.audio {
	class SoundTransform{
		constructor(volume: number);
		volume: number;
		left: number;
		right: number;
		dispose(): void ;
		static create(volume: number): minko.audio.SoundTransform ;
	}
}

export namespace minko.component {
	class AnimationLabel{
		constructor(n: string, t: number);
		name: string;
		time: number;
	}
}

export namespace minko.component {
	class AbstractAnimation extends minko.component.AbstractComponent{
		constructor(isLooping: boolean);
		play(): void ;
		stop(): void ;
		clone(option: number): minko.component.AbstractComponent ;
		seek(currentTime: number): void ;
		readonly currentTime: number;
		readonly loopStartTime: number;
		readonly loopEndTime: number;
		hasLabel(name: string): boolean ;
		getLabel(name: string): minko.component.AnimationLabel ;
		addLabel(name: string, time: number): void ;
		changeLabel(name: string, newName: string): void ;
		setTimeForLabel(name: string, newTime: number): void ;
		removeLabel(name: string): void ;
		setPlaybackWindow(beginTime: number, endTime: number, forceRestart?: boolean): void ;
		setPlaybackWindowbyName(beginLabelName: string, endLabelName: string, forceRestart?: boolean): void ;
		resetPlaybackWindow(): void ;
		readonly numLabels: number;
		labelTimebyName(name: string): number ;
		isPlaying: boolean;
		isLooping: boolean;
		isReversed: boolean;
		readonly maxTime: number;
		timeFunction: (arg0: number) => number;
		readonly started: minko.signal.Signal<minko.component.AbstractAnimation>;
		readonly looped: minko.signal.Signal<minko.component.AbstractAnimation>;
		readonly stopped: minko.signal.Signal<minko.component.AbstractAnimation>;
		readonly labelHit: minko.signal.Signal3<minko.component.AbstractAnimation, string, number>;
		copyFrom(absAnimation: minko.component.AbstractAnimation, option: number): minko.component.AbstractAnimation ;
		dispose(): void ;
		initialize(): void ;
		targetAdded(node: minko.scene.Node): void ;
		targetRemoved(node: minko.scene.Node): void ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		removedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		componentAddedHandler(node: minko.scene.Node, target: minko.scene.Node, component: minko.component.AbstractComponent): void ;
		componentRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, component: minko.component.AbstractComponent): void ;
		findSceneManager(): void ;
		setSceneManager(sceneManager: minko.component.SceneManager): void ;
		frameBeginHandler(sceneManager: minko.component.SceneManager, time: number, UnnamedParameter1: number): void ;
		updateNextLabelIds(time: number): void ;
		checkLabelHit(previousTime: number, newTime: number): void ;
		isInPlaybackWindow(time: number): boolean ;
		update(): void ;
		updateRaw(rawGlobalTime: number): boolean ;
		getNewLoopTime(time: number, deltaTime: number): number ;
	}
}

export namespace minko.component {
	class AbstractRootDataComponent extends minko.component.AbstractComponent{
		constructor(collectionName: string);
		dispose(): void ;
		readonly provider: minko.data.Provider;
		readonly root: minko.scene.Node;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		addedOrRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, ancestor: minko.scene.Node): void ;
		updateRoot(root: minko.scene.Node): void ;
	}
}

export namespace minko.component {
	class AbstractLight extends minko.component.AbstractRootDataComponent{
		constructor(collectionName: string);
		readonly data: minko.data.Provider;
		dispose(): void ;
		color: glm.Vec3Base;
	}
}

export namespace minko.component {
	class AbstractDiscreteLight extends minko.component.AbstractLight{
		constructor(arrayName: string, diffuse?: number, specular?: number);
		diffuse: number;
		specular: number;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		modelToWorldMatrixChangedHandler(container: minko.data.Store, propertyName: string): void ;
		updateModelToWorldMatrix(modelToWorld: glm.Mat4Base): void ;
	}
}

export namespace minko.component {
	class AmbientLight extends minko.component.AbstractLight{
		constructor(ambient: number);
		clone(option: number): minko.component.AbstractComponent ;
		ambient: number;
		copyFrom(ambientLight: minko.component.AmbientLight, option: number): minko.component.AmbientLight ;
		static create(ambient: number): minko.component.AmbientLight ;
	}
}

export namespace minko.component {
	class Animation extends minko.component.AbstractAnimation{
		constructor(timelines: minko.animation.AbstractTimeline[], isLooping: boolean);
		clone(option: number): minko.component.Animation ;
		rebindDependencies(componentsMap: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, option: number): void ;
		readonly numTimelines: number;
		getTimeline(timelineId: number): minko.animation.AbstractTimeline ;
		initialize(): void ;
		copyFromAnimation(anim: minko.component.Animation, option: number): minko.component.Animation ;
		update(): void ;
		frameBeginHandler(manager: minko.component.SceneManager, time: number, deltaTime: number): void ;
		updateNextLabelIds(time: number): void ;
		checkLabelHit(previousTime: number, newTime: number): void ;
		static create(timelines: minko.animation.AbstractTimeline[], isLooping?: boolean): minko.component.Animation ;
	}
}

export namespace minko.component {
	class BoundingBox extends minko.component.AbstractComponent{
		constructor();
		clone(option: number): minko.component.BoundingBox ;
		readonly shape: minko.math.Box;
		readonly box: minko.math.Box;
		readonly modelSpaceBox: minko.math.Box;
		update(): void ;
		setVector3(topRight: glm.Vec3Base, bottomLeft: glm.Vec3Base): minko.component.BoundingBox ;
		copyFrom(bbox: minko.component.BoundingBox, option?: number): void ;
		static create(): minko.component.BoundingBox ;
		static createbySize(size: number, center: glm.Vec3Base): minko.component.BoundingBox ;
		static createbyWHDC(width: number, height: number, depth: number, center: glm.Vec3Base): minko.component.BoundingBox ;
		static createbyVector3(topRight: glm.Vec3Base, bottomLeft: glm.Vec3Base): minko.component.BoundingBox ;
	}
}

export namespace minko.component {
	class Culling extends minko.component.AbstractComponent{
		constructor(shape: minko.math.AbstractShape, bindProperty: string, layout: number);
		worldSize: number;
		maxDepth: number;
		readonly octTree: minko.math.OctTree;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		static create(shape: minko.math.AbstractShape, bindPropertyName: string, layout?: number): minko.component.Culling ;
	}
}

export namespace minko.component {
	class DirectionalLight extends minko.component.AbstractDiscreteLight{
		constructor(diffuse: number, specular: number);
		clone(option: number): minko.component.DirectionalLight ;
		readonly shadowMap: minko.render.Texture;
		shadowSpread: number;
		readonly shadowProjections: glm.Mat4Base[];
		readonly shadowMappingEnabled: boolean;
		readonly numShadowCascades: number;
		computeShadowProjection(view: glm.Mat4Base, projection: glm.Mat4Base, zFar?: number, fitToCascade?: boolean): void ;
		enableShadowMapping(shadowMapSize: number, numCascades?: number): void ;
		disableShadowMapping(disposeResources: boolean): void ;
		updateModelToWorldMatrix(modelToWorld: glm.Mat4Base): void ;
		updateRoot(root: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		copyFrom(directionalLight: minko.component.DirectionalLight, option: number): void ;
		minSphere(pt: glm.Vec3Base[], np: number, bnd: glm.Vec3Base[], nb: number): void ;
		static readonly MAX_NUM_SHADOW_CASCADES: number;
		static readonly DEFAULT_NUM_SHADOW_CASCADES: number;
		static readonly MIN_SHADOWMAP_SIZE: number;
		static readonly MAX_SHADOWMAP_SIZE: number;
		static readonly DEFAULT_SHADOWMAP_SIZE: number;
		static create(diffuse: number, specular?: number): minko.component.DirectionalLight ;
	}
}

export namespace minko.component {
	class FrustumDisplay extends minko.component.AbstractComponent{
		constructor(projection: glm.Mat4Base);
		readonly material: minko.material.BasicMaterial;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, added: minko.scene.Node): void ;
		initialize(): void ;
		initializePlanes(vertices: glm.Vec3Base[]): void ;
		initializeLines(vertices: glm.Vec3Base[]): void ;
		initializeFrustumGeometry(vertices: glm.Vec3Base[], context: minko.render.AbstractContext): minko.geometry.Geometry ;
		getVertices(): glm.Vec3Base[] ;
		static create(projection: glm.Mat4Base): minko.component.FrustumDisplay ;
	}
}

export namespace minko.component {
	class ImageBasedLight extends minko.component.AbstractLight{
		constructor();
		diffuse: number;
		specular: number;
		irradianceMap: minko.render.Texture;
		radianceMap: minko.render.Texture;
		brightness: number;
		orientation: number;
		static create(): minko.component.ImageBasedLight ;
	}
}

export namespace minko.component {
	class Job{
		constructor();
		readonly complete: number;
		beforeFirstStep(): void ;
		step(): void ;
		priority: number;
		afterLastStep(): void ;
		running: boolean;
		jobManager: minko.component.JobManager;
		readonly priorityChanged: minko.signal.Signal<number>;
	}
}

export namespace minko.component {
	class JobManager extends minko.component.AbstractScript{
		constructor(loadingFramerate: number);
		pushJob(job: minko.component.Job): minko.component.JobManager ;
		update(target: minko.scene.Node): void ;
		end(target: minko.scene.Node): void ;
		static create(loadingFramerate: number): minko.component.JobManager ;
	}
}

export namespace minko.component {
	class MasterAnimation extends minko.component.AbstractAnimation{
		constructor(isLooping: boolean);
		seekLabel(labelName: string): void ;
		play(): void ;
		stop(): void ;
		seek(time: number): void ;
		clone(option: number): minko.component.MasterAnimation ;
		addLabel(name: string, time: number): void ;
		changeLabel(name: string, newName: string): void ;
		setTimeForLabel(name: string, newTime: number): void ;
		removeLabel(name: string): void ;
		setPlaybackWindow(beginLabelName: number, endLabelName: number, forceRestart?: boolean): void ;
		resetPlaybackWindow(): void ;
		initAnimations(): void ;
		rebindDependencies(componentsMap: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, option: number): void ;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		update(): void ;
		static create(isLooping: boolean): minko.component.MasterAnimation ;
	}
}

export namespace minko.component {
	class Metadata extends minko.component.AbstractComponent{
		constructor(__data: haxe.ds.StringMap<string>);
		readonly data: haxe.ds.StringMap<string>;
		get(propertyName: string): string ;
		set(propertyName: string, value: string): void ;
		has(propertyName: string): boolean ;
		static create(data: haxe.ds.StringMap<string>): minko.component.Metadata ;
	}
}

export namespace minko.component {
	class MouseManager extends minko.component.AbstractComponent{
		constructor(mouse: minko.input.Mouse);
		readonly mouse: minko.input.Mouse;
		pick(ray: minko.math.Ray): void ;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		initialize(): void ;
		static create(mouse: minko.input.Mouse): minko.component.MouseManager ;
	}
}

export namespace minko.component {
	class MousePicking extends minko.component.AbstractComponent{
		constructor();
		readonly move: minko.signal.Signal3<minko.component.MousePicking, minko.Tuple<minko.scene.Node, number>[], minko.math.Ray>;
		readonly over: minko.signal.Signal3<minko.component.MousePicking, minko.Tuple<minko.scene.Node, number>[], minko.math.Ray>;
		pick(ray: minko.math.Ray): void ;
		static create(): minko.component.MousePicking ;
	}
}

export namespace minko.component {
	class PerspectiveCamera extends minko.component.AbstractComponent{
		constructor(fov: number, aspectRatio: number, zNear: number, zFar: number, postPerspective: glm.Mat4Base);
		fieldOfView: number;
		aspectRatio: number;
		zNear: number;
		zFar: number;
		readonly data: minko.data.Provider;
		readonly viewMatrix: glm.Mat4Base;
		readonly projectionMatrix: glm.Mat4Base;
		readonly viewProjectionMatrix: glm.Mat4Base;
		updateProjection(fov: number, aspectRatio: number, zNear: number, zFar: number): void ;
		unproject(x: number, y: number): minko.math.Ray ;
		project(worldPosition: glm.Vec3Base): glm.Vec3Base ;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		static create(aspectRatio: number, fov?: number, zNear?: number, zFar?: number, postProjection?: glm.Mat4Base): minko.component.PerspectiveCamera ;
		static projectWorldPosition(worldPosition: glm.Vec3Base, viewportWidth: number, viewportHeight: number, viewMatrix: glm.Mat4Base, viewProjectionMatrix: glm.Mat4Base): glm.Vec3Base ;
	}
}

export namespace minko.component {
	class Picking extends minko.component.AbstractComponent{
		constructor();
		readonly mouseOver: minko.signal.Signal<minko.scene.Node>;
		readonly mouseRightDown: minko.signal.Signal<minko.scene.Node>;
		readonly mouseRightUp: minko.signal.Signal<minko.scene.Node>;
		readonly mouseDown: minko.signal.Signal<minko.scene.Node>;
		readonly mouseUp: minko.signal.Signal<minko.scene.Node>;
		readonly mouseRightClick: minko.signal.Signal<minko.scene.Node>;
		readonly mouseClick: minko.signal.Signal<minko.scene.Node>;
		readonly mouseOut: minko.signal.Signal<minko.scene.Node>;
		readonly mouseMove: minko.signal.Signal<minko.scene.Node>;
		readonly mouseWheel: minko.signal.Signal<minko.scene.Node>;
		readonly touchDown: minko.signal.Signal<minko.scene.Node>;
		readonly touchMove: minko.signal.Signal<minko.scene.Node>;
		readonly touchUp: minko.signal.Signal<minko.scene.Node>;
		readonly touchTap: minko.signal.Signal<minko.scene.Node>;
		readonly touchDoubleTap: minko.signal.Signal<minko.scene.Node>;
		readonly touchLongHold: minko.signal.Signal<minko.scene.Node>;
		readonly pickedSurface: minko.component.Surface;
		renderDepth: boolean;
		readonly pickedDepth: number;
		readonly pickedMergingMask: number;
		debug: boolean;
		targetRemoved(target: minko.scene.Node): void ;
		initialize(camera: minko.scene.Node, addPickingLayout: boolean, emulateMouseWithTouch: boolean, pickingEffect: minko.render.Effect, pickingDepthEffect: minko.render.Effect): void ;
		targetAdded(target: minko.scene.Node): void ;
		addedHandler(target: minko.scene.Node, child: minko.scene.Node, parent: minko.scene.Node): void ;
		componentAddedHandler(target: minko.scene.Node, node: minko.scene.Node, ctrl: minko.component.AbstractComponent): void ;
		componentRemovedHandler(target: minko.scene.Node, node: minko.scene.Node, ctrl: minko.component.AbstractComponent): void ;
		addSurface(surface: minko.component.Surface): void ;
		removeSurface(surface: minko.component.Surface, node: minko.scene.Node): void ;
		removedHandler(target: minko.scene.Node, child: minko.scene.Node, parent: minko.scene.Node): void ;
		addSurfacesForNode(node: minko.scene.Node): void ;
		removeSurfacesForNode(node: minko.scene.Node): void ;
		updateDescendants(target: minko.scene.Node): void ;
		enabled: boolean;
		frameBeginHandler(UnnamedParameter1: minko.component.SceneManager, UnnamedParameter2: number, UnnamedParameter3: number): void ;
		renderingBegin(renderer: minko.component.Renderer): void ;
		renderingEnd(renderer: minko.component.Renderer): void ;
		depthRenderingBegin(renderer: minko.component.Renderer): void ;
		depthRenderingEnd(renderer: minko.component.Renderer): void ;
		updatePickingProjection(): void ;
		updatePickingOrigin(): void ;
		dispatchEvents(pickedSurface: minko.component.Surface, depth: number): void ;
		mouseMoveHandler(mouse: minko.input.Mouse, dx: number, dy: number): void ;
		mouseRightUpHandler(mouse: minko.input.Mouse): void ;
		mouseLeftUpHandler(mouse: minko.input.Mouse): void ;
		mouseRightClickHandler(mouse: minko.input.Mouse): void ;
		mouseLeftClickHandler(mouse: minko.input.Mouse): void ;
		mouseRightDownHandler(mouse: minko.input.Mouse): void ;
		mouseLeftDownHandler(mouse: minko.input.Mouse): void ;
		mouseWheelHandler(mouse: minko.input.Mouse, x: number, y: number): void ;
		touchDownHandler(touch: minko.input.Touch, identifier: number, x: number, y: number): void ;
		touchUpHandler(touch: minko.input.Touch, identifier: number, x: number, y: number): void ;
		touchMoveHandler(touch: minko.input.Touch, identifier: number, x: number, y: number): void ;
		touchTapHandler(touch: minko.input.Touch, x: number, y: number): void ;
		touchDoubleTapHandler(touch: minko.input.Touch, x: number, y: number): void ;
		touchLongHoldHandler(touch: minko.input.Touch, x: number, y: number): void ;
		static create(camera: minko.scene.Node, addPickingLayoutToNodes?: boolean, emulateMouseWithTouch?: boolean, pickingEffect?: minko.render.Effect, pickingDepthEffect?: minko.render.Effect): minko.component.Picking ;
	}
}

export namespace minko.component {
	class PointLight extends minko.component.AbstractDiscreteLight{
		constructor(diffuse: number, specular: number, attenuationConstant: number, attenuationLinear: number, attenuationQuadratic: number);
		clone(option: number): minko.component.PointLight ;
		readonly attenuationEnabled: boolean;
		attenuationCoefficients: glm.Vec3Base;
		setAttenuationCoefficients(constant: number, linear: number, quadratic: number): glm.Vec3Base ;
		readonly position: glm.Vec3Base;
		updateModelToWorldMatrix(modelToWorld: glm.Mat4Base): void ;
		copyFrom(pointLight: minko.component.PointLight, option: number): minko.component.PointLight ;
		static create(diffuse: number, specular?: number, attenuationConstant?: number, attenuationLinear?: number, attenuationQuadratic?: number): minko.component.PointLight ;
	}
}

export namespace minko.component {
	class Reflection extends minko.component.AbstractScript{
		constructor(assets: minko.file.AssetLibrary, renderTargetWidth?: number, renderTargetHeight?: number, clearColor?: number);
		readonly renderTarget: minko.render.Texture;
		copyFrom(reflection: minko.component.Reflection, option: number): minko.component.Reflection ;
		clone(option: number): minko.component.Reflection ;
		start(target: minko.scene.Node): void ;
		update(target: minko.scene.Node): void ;
		stop(target: minko.scene.Node): void ;
		updateReflectionMatrix(): void ;
		static create(assets: minko.file.AssetLibrary, renderTargetWidth: number, renderTargetHeight: number, clearColor: number): minko.component.Reflection ;
	}
}

export namespace minko.component {
	class Renderer extends minko.component.AbstractComponent{
		constructor(renderTarget: minko.render.AbstractTexture, effect: minko.render.Effect, effectTechnique: string, priority: number);
		effect: minko.render.Effect;
		setEffect(effect: minko.render.Effect, technique: string): void ;
		readonly numDrawCalls: number;
		readonly numTriangles: number;
		backgroundColor: number;
		name: string;
		priority: number;
		viewport: glm.Vec4Base;
		scissorBox(x: number, y: number, w: number, h: number): void ;
		renderTarget: minko.render.AbstractTexture;
		clearBeforeRender: boolean;
		readonly effectVariables: minko.Tuple<string, string>[];
		effectTechnique: string;
		enabled: boolean;
		readonly drawCallPool: minko.render.DrawCallPool;
		readonly renderingBegin: minko.signal.Signal<minko.component.Renderer>;
		readonly beforePresent: minko.signal.Signal<minko.component.Renderer>;
		readonly renderingEnd: minko.signal.Signal<minko.component.Renderer>;
		reset(): void ;
		initializePostProcessingGeometry(): void ;
		targetAdded(target: minko.scene.Node): void ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		removedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		rootDescendantAddedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		rootDescendantRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		componentAddedHandler(node: minko.scene.Node, target: minko.scene.Node, ctrl: minko.component.AbstractComponent): void ;
		addToCollect(surfaceCtrl: minko.component.Surface): void ;
		componentRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, cmp: minko.component.AbstractComponent): void ;
		addSurface(surface: minko.component.Surface): void ;
		removeSurface(surface: minko.component.Surface): void ;
		surfaceGeometryOrMaterialChangedHandler(surface: minko.component.Surface): void ;
		surfaceEffectChangedHandler(surface: minko.component.Surface): void ;
		render(context: minko.render.AbstractContext, renderTarget?: minko.render.AbstractTexture): void ;
		clear(canvas: minko.AbstractCanvas): void ;
		clearbyVector4(canvas: minko.AbstractCanvas, clearColor: glm.Vec4Base): void ;
		findSceneManager(): void ;
		setSceneManager(sceneManager: minko.component.SceneManager): void ;
		sceneManagerRenderingBeginHandler(sceneManager: minko.component.SceneManager, frameId: number, renderTarget: minko.render.AbstractTexture): void ;
		addFilter(filter: minko.data.AbstractFilter, source: number): minko.component.Renderer ;
		removeFilter(filter: minko.data.AbstractFilter, source: number): minko.component.Renderer ;
		surfaceLayoutMaskChangedHandler(surface: minko.component.Surface): void ;
		watchSurface(surface: minko.component.Surface): void ;
		unwatchSurface(surface: minko.component.Surface, node: minko.scene.Node): void ;
		checkSurfaceLayout(surface: minko.component.Surface): boolean ;
		enableDrawCalls(surface: minko.component.Surface, enabled: boolean): void ;
		changeEffectOrTechnique(effect: minko.render.Effect, technique: string): void ;
		static create(backgroundColor: number, renderTarget?: minko.render.AbstractTexture, effect?: minko.render.Effect, effectTechnique?: string, priority?: number, name?: string): minko.component.Renderer ;
	}
}

export namespace minko.component {
	class SceneManager extends minko.component.AbstractComponent{
		constructor(canvas: minko.AbstractCanvas);
		readonly canvas: minko.AbstractCanvas;
		readonly frameId: number;
		readonly assets: minko.file.AssetLibrary;
		readonly frameBegin: minko.signal.Signal3<minko.component.SceneManager, number, number>;
		readonly frameEnd: minko.signal.Signal3<minko.component.SceneManager, number, number>;
		readonly cullingBegin: minko.signal.Signal<minko.component.SceneManager>;
		readonly cullingEnd: minko.signal.Signal<minko.component.SceneManager>;
		readonly renderingBegin: minko.signal.Signal3<minko.component.SceneManager, number, minko.render.AbstractTexture>;
		readonly renderingEnd: minko.signal.Signal3<minko.component.SceneManager, number, minko.render.AbstractTexture>;
		readonly time: number;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, ancestor: minko.scene.Node): void ;
		nextFrame(time: number, deltaTime: number, renderTarget?: minko.render.AbstractTexture): void ;
		static create(canvas: minko.AbstractCanvas): minko.component.SceneManager ;
	}
}

export namespace minko.component {
	class Technique{
		private constructor();
		static readonly DEFAULT: number;
		static readonly ESM: number;
		static readonly PCF: number;
		static readonly PCF_POISSON: number;
	}
}

export namespace minko.component {
	class ShadowMappingTechnique extends minko.component.AbstractComponent{
		constructor(technique: number);
		targetAdded(target: minko.scene.Node): void ;
		static create(technique: number): minko.component.ShadowMappingTechnique ;
	}
}

export namespace minko.component {
	class SkinningMethod{
		private constructor();
		static readonly SOFTWARE: number;
		static readonly HARDWARE: number;
	}
}

export namespace minko.component {
	class Skinning extends minko.component.AbstractAnimation{
		constructor(skin: minko.geometry.Skin, method: number, context: minko.render.AbstractContext, skeletonRoot: minko.scene.Node, moveTargetBelowRoot: boolean, isLooping: boolean);
		clone(option: number): minko.component.Skinning ;
		readonly skin: minko.geometry.Skin;
		initialize(): void ;
		targetAdded(target: minko.scene.Node): void ;
		copyFromSkinning(skinning: minko.component.Skinning, option: number): minko.component.Skinning ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		removedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		update(): void ;
		updateFrame(frameId: number, target: minko.scene.Node): void ;
		performSoftwareSkinningFrame(target: minko.scene.Node, boneMatrices: glm.Mat4Base[]): void ;
		rebindDependencies(componentsMap: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, option: number): void ;
		static PNAME_NUM_BONES: string;
		static PNAME_BONE_MATRICES: string;
		static ATTRNAME_BONE_IDS_A: string;
		static ATTRNAME_BONE_IDS_B: string;
		static ATTRNAME_BONE_WEIGHTS_A: string;
		static ATTRNAME_BONE_WEIGHTS_B: string;
		static MAX_NUM_BONES_PER_VERTEX: number;
		static create(skin: minko.geometry.Skin, method: number, context: minko.render.AbstractContext, skeletonRoot: minko.scene.Node, moveTargetBelowRoot?: boolean, isLooping?: boolean): minko.component.Skinning ;
	}
}

export namespace minko.component {
	class SpotLight extends minko.component.AbstractDiscreteLight{
		constructor(diffuse: number, specular: number, innerAngleRadians: number, outerAngleRadians: number, attenuationConstant: number, attenuationLinear: number, attenuationQuadratic: number);
		clone(option: number): minko.component.SpotLight ;
		innerConeAngle: number;
		outerConeAngle: number;
		readonly attenuationEnabled: boolean;
		attenuationCoefficients: glm.Vec3Base;
		setAttenuationCoefficients(constant: number, linear: number, quadratic: number): glm.Vec3Base ;
		readonly position: glm.Vec3Base;
		updateModelToWorldMatrix(modelToWorld: glm.Mat4Base): void ;
		static readonly PI: number;
		static create(diffuse: number, specular?: number, innerAngleRadians?: number, outerAngleRadians?: number, attenuationConstant?: number, attenuationLinear?: number, attenuationQuadratic?: number): minko.component.SpotLight ;
	}
}

export namespace minko.component {
	class Surface extends minko.component.AbstractComponent{
		constructor(name: string, geometry: minko.geometry.Geometry, material: minko.material.Material, effect: minko.render.Effect, technique: string);
		dispose(): void ;
		name: string;
		readonly data: minko.data.Provider;
		geometry: minko.geometry.Geometry;
		firstIndex: number;
		numIndices: number;
		material: minko.material.Material;
		effect: minko.render.Effect;
		readonly technique: string;
		readonly geometryChanged: minko.signal.Signal<minko.component.Surface>;
		readonly materialChanged: minko.signal.Signal<minko.component.Surface>;
		readonly effectChanged: minko.signal.Signal<minko.component.Surface>;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		setEffectAndTechnique(effect: minko.render.Effect, technique: string): void ;
		initializeIndexRange(geometry: minko.geometry.Geometry): void ;
		static readonly SURFACE_COLLECTION_NAME: string;
		static readonly GEOMETRY_COLLECTION_NAME: string;
		static readonly MATERIAL_COLLECTION_NAME: string;
		static readonly EFFECT_COLLECTION_NAME: string;
		static create(geometry: minko.geometry.Geometry, material: minko.material.Material, effect?: minko.render.Effect, technique?: string, name?: string): minko.component.Surface ;
	}
}

export namespace minko.component {
	class RootTransform extends minko.component.AbstractComponent{
		constructor();
		dispose(): void ;
		setDirty(target: minko.scene.Node, d: boolean): void ;
		clone(option: number): minko.component.RootTransform ;
		targetAdded(target: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		componentAddedHandler(node: minko.scene.Node, target: minko.scene.Node, ctrl: minko.component.AbstractComponent): void ;
		componentRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, ctrl: minko.component.AbstractComponent): void ;
		addedHandler(node: minko.scene.Node, target: minko.scene.Node, ancestor: minko.scene.Node): void ;
		removedHandler(node: minko.scene.Node, target: minko.scene.Node, ancestor: minko.scene.Node): void ;
		updateTransformsList(): void ;
		sortNodes(): void ;
		updateTransforms(): void ;
		forceUpdate(node: minko.scene.Node, updateTransformLists: boolean): void ;
		renderingBeginHandler(sceneManager: minko.component.SceneManager, frameId: number, abstractTexture: minko.render.AbstractTexture): void ;
		static create(): minko.component.RootTransform ;
	}
}

export namespace minko.component {
	class NodeTransformCacheEntry{
		constructor();
		_node: minko.scene.Node;
		_matrix: glm.Mat4Base;
		_modelToWorldMatrix: glm.Mat4Base;
		_parentId: number;
		_firstChildId: number;
		_numChildren: number;
		_dirty: boolean;
		_provider: minko.data.Provider;
	}
}

export namespace minko.component {
	class Transform extends minko.component.AbstractComponent{
		constructor();
		dispose(): void ;
		clone(option: number): minko.component.Transform ;
		readonly data: minko.data.Provider;
		dirty: boolean;
		matrix: glm.Mat4Base;
		readonly modelToWorldMatrix: glm.Mat4Base;
		_modelToWorldMatrix(forceUpdate: boolean): glm.Mat4Base ;
		updateModelToWorldMatrix(): void ;
		targetAdded(target: minko.scene.Node): void ;
		addedOrRemovedHandler(node: minko.scene.Node, target: minko.scene.Node, parent: minko.scene.Node): void ;
		targetRemoved(target: minko.scene.Node): void ;
		static create(): minko.component.Transform ;
		static createbyMatrix4(transform: glm.Mat4Base): minko.component.Transform ;
	}
}

export namespace minko.data {
	class AbstractFilter{
		constructor();
		readonly currentSurface: minko.component.Surface;
		get_currentSurface(): minko.component.Surface ;
		readonly changed: minko.signal.Signal2<minko.data.AbstractFilter, minko.component.Surface>;
		get_changed(): minko.signal.Signal2<minko.data.AbstractFilter, minko.component.Surface> ;
		watchProperty(propertyName: string): void ;
		unwatchProperty(propertyName: string): void ;
	}
}

export namespace minko.data {
	class Source{
		private constructor();
		static readonly TARGET: number;
		static readonly RENDERER: number;
		static readonly ROOT: number;
	}
}

export namespace minko.data {
	class Binding extends minko.Enable_uuid{
		constructor();
		propertyName: string;
		source: number;
		setBinding(propertyName: string, source: number): minko.data.Binding ;
	}
}

export namespace minko.data {
	class BindingMapBase<T> extends minko.Enable_uuid{
		constructor();
		defaultValues: minko.data.Store;
		bindings: haxe.ds.StringMap<T>;
		setBindingsAndStore(bindings: haxe.ds.StringMap<T>, defaultValues: minko.data.Store): void ;
		dispose(): void ;
		static copyFrom<T>(t: minko.data.BindingMapBase<T>, m: minko.data.BindingMapBase<T>): minko.data.BindingMapBase<T> ;
	}
}

export namespace minko.data {
	class MacroBinding extends minko.data.Binding{
		constructor();
		minValue: number;
		maxValue: number;
		setBindingMinMax(min: number, max: number): void ;
		dispose(): void ;
	}
}

export namespace minko.data {
	class MacroType{
		private constructor();
		static readonly UNSET: number;
		static readonly INT: number;
		static readonly INT2: number;
		static readonly INT3: number;
		static readonly INT4: number;
		static readonly BOOL: number;
		static readonly BOOL2: number;
		static readonly BOOL3: number;
		static readonly BOOL4: number;
		static readonly FLOAT: number;
		static readonly FLOAT2: number;
		static readonly FLOAT3: number;
		static readonly FLOAT4: number;
		static readonly FLOAT9: number;
		static readonly FLOAT16: number;
	}
}

export namespace minko.data {
	class MacroBindingMap extends minko.data.BindingMapBase<minko.data.MacroBinding>{
		constructor();
		types: haxe.ds.StringMap<number>;
		static copyFrom2(t: minko.data.MacroBindingMap, m: minko.data.MacroBindingMap): minko.data.MacroBindingMap ;
		static stringToMacroType(s: string): number ;
	}
}

export namespace minko.data {
	class Collection{
		constructor(name: string);
		dispose(): void ;
		readonly name: string;
		readonly items: minko.data.Provider[];
		readonly itemAdded: minko.signal.Signal2<minko.data.Collection, minko.data.Provider>;
		readonly itemRemoved: minko.signal.Signal2<minko.data.Collection, minko.data.Provider>;
		readonly front: minko.data.Provider;
		readonly back: minko.data.Provider;
		insert(position: number, provider: minko.data.Provider): minko.data.Collection ;
		erase(position: number): minko.data.Collection ;
		remove(provider: minko.data.Provider): minko.data.Collection ;
		pushBack(provider: minko.data.Provider): minko.data.Collection ;
		popBack(): minko.data.Collection ;
		static create(name: string): minko.data.Collection ;
		static createbyCollection(collection: minko.data.Collection, deepCopy?: boolean): minko.data.Collection ;
	}
}

export namespace minko.data {
	class PixelData{
		constructor(w: number, h: number, p: haxe.io.Bytes);
		pixels: haxe.io.Bytes;
		width: number;
		height: number;
	}
}

export namespace minko.data {
	class Provider extends minko.Enable_uuid{
		constructor();
		dispose(): void ;
		front(): any ;
		hasProperty(propertyName: string): boolean ;
		readonly values: haxe.ds.StringMap<any>;
		readonly propertyAdded: minko.signal.Signal2<minko.data.Provider, string>;
		readonly propertyChanged: minko.signal.Signal2<minko.data.Provider, string>;
		readonly propertyRemoved: minko.signal.Signal2<minko.data.Provider, string>;
		get(propertyName: string): any ;
		getUnsafePointer(propertyName: string): any ;
		set(propertyName: string, value: any): minko.data.Provider ;
		setProvider(values: haxe.ds.StringMap<any>): void ;
		propertyHasType(propertyName: string): boolean ;
		clear(): void ;
		unset(propertyName: string): void ;
		copyFrom(source: minko.data.Provider): minko.data.Provider ;
		static create(): minko.data.Provider ;
		static createbyUuid(uuid: string): minko.data.Provider ;
		static createbyStringMap(values: haxe.ds.StringMap<any>): minko.data.Provider ;
		static createbyProvider(source: minko.data.Provider): minko.data.Provider ;
	}
}

export namespace minko.data {
	class ResolvedBinding{
		constructor(binding: minko.data.Binding, propertyName: string, store: minko.data.Store);
		binding: minko.data.Binding;
		propertyName: string;
		store: minko.data.Store;
	}
}

export namespace minko.data {
	class Store extends minko.Enable_uuid{
		constructor();
		dispose(): void ;
		propertyHasType(propertyName: string): boolean ;
		get(propertyName: string): any ;
		getUnsafePointer(propertyName: string): any ;
		set(propertyName: string, value: any): minko.data.Store ;
		readonly propertyAdded: minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>;
		get_propertyAdded(): minko.signal.Signal3<minko.data.Store, minko.data.Provider, string> ;
		readonly propertyRemoved: minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>;
		readonly propertyChanged: minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>;
		getPropertyAdded(propertyName: string): minko.signal.Signal3<minko.data.Store, minko.data.Provider, string> ;
		getPropertyRemoved(propertyName: string): minko.signal.Signal3<minko.data.Store, minko.data.Provider, string> ;
		getPropertyChanged(propertyName: string): minko.signal.Signal3<minko.data.Store, minko.data.Provider, string> ;
		providers: minko.data.Provider[];
		readonly collections: minko.data.Collection[];
		addProvider(provider: minko.data.Provider): void ;
		addProviderbyName(provider: minko.data.Provider, collectionName: string): void ;
		removeProvider(provider: minko.data.Provider): void ;
		removeProviderbyName(provider: minko.data.Provider, collectionName: string): void ;
		addCollection(collection: minko.data.Collection): void ;
		removeCollection(collection: minko.data.Collection): void ;
		hasProperty(propertyName: string): boolean ;
		hasPropertyAddedSignal(propertyName: string): boolean ;
		hasPropertyRemovedSignal(propertyName: string): boolean ;
		hasPropertyChangedSignal(propertyName: string): boolean ;
		doRemoveProvider(provider: minko.data.Provider, collection?: minko.data.Collection): void ;
		formatPropertyName(collection: minko.data.Collection, provider: minko.data.Provider, propertyName: string, useUuid?: boolean): string ;
		formatPropertyIndexName(collection: minko.data.Collection, index: string, propertyName: string): string ;
		executePropertySignal(provider: minko.data.Provider, collection: minko.data.Collection, propertyName: string, anyChangedSignal: minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>, propertyNameToSignal: haxe.ds.StringMap<minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>>): void ;
		providerPropertyAddedHandler(provider: minko.data.Provider, collection: minko.data.Collection, propertyName: string): void ;
		providerPropertyRemovedHandler(provider: minko.data.Provider, collection: minko.data.Collection, propertyName: string): void ;
		doAddProvider(provider: minko.data.Provider, collection?: minko.data.Collection): void ;
		updateCollectionLength(collection: minko.data.Collection): void ;
		copyFrom(store: minko.data.Store, deepCopy?: boolean): minko.data.Store ;
		getOrInsertSignal(signals: haxe.ds.StringMap<minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>>, propertyName: string): minko.signal.Signal3<minko.data.Store, minko.data.Provider, string> ;
		static getActualPropertyName(vars: minko.Tuple<string, string>[], propertyName: string): string ;
	}
}

export namespace minko.file {
	class AbstractAssetDescriptor{
		constructor();
		location: minko.file.AssetLocation;
		dispose(): void ;
	}
}

export namespace minko.file {
	class AbstractParser{
		constructor();
		_progress: minko.signal.Signal2<minko.file.AbstractParser, number>;
		_complete: minko.signal.Signal<minko.file.AbstractParser>;
		_error: minko.signal.Signal2<minko.file.AbstractParser, string>;
		dispose(): void ;
		readonly progress: minko.signal.Signal2<minko.file.AbstractParser, number>;
		readonly complete: minko.signal.Signal<minko.file.AbstractParser>;
		readonly error: minko.signal.Signal2<minko.file.AbstractParser, string>;
		parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: haxe.io.Bytes, assetLibrary: minko.file.AssetLibrary): void ;
	}
}

export namespace minko.file {
	class AbstractProtocol{
		constructor();
		dispose(): void ;
		readonly file: minko.file.File;
		options: minko.file.Options;
		readonly progress: minko.signal.Signal2<minko.file.AbstractProtocol, number>;
		readonly complete: minko.signal.Signal<minko.file.AbstractProtocol>;
		readonly error: minko.signal.Signal2<minko.file.AbstractProtocol, string>;
		loadFile(filename: string, resolvedFilename: string, options: minko.file.Options): void ;
		load(): void ;
		fileExists(filename: string): boolean ;
		isAbsolutePath(filename: string): boolean ;
		readonly resolvedFilename: string;
		data: haxe.io.Bytes;
	}
}

export namespace minko.file {
	class AssetLibrary{
		constructor(context: minko.render.AbstractContext);
		readonly numGeometries: number;
		readonly numMaterials: number;
		readonly numEffects: number;
		readonly numTextures: number;
		readonly context: minko.render.AbstractContext;
		readonly loader: minko.file.Loader;
		disposeLoader(): void ;
		geometry(name: string): minko.geometry.Geometry ;
		setGeometry(name: string, geometry: minko.geometry.Geometry): minko.file.AssetLibrary ;
		geometryName(geometry: minko.geometry.Geometry): string ;
		texture(name: string): minko.render.Texture ;
		setTexture(name: string, texture: minko.render.Texture): minko.file.AssetLibrary ;
		getTextureByUuid(uuid: string, failIfNotReady: boolean): minko.render.Texture ;
		cubeTexture(name: string): minko.render.CubeTexture ;
		setCubeTexture(name: string, texture: minko.render.CubeTexture): minko.file.AssetLibrary ;
		rectangleTexture(name: string): minko.render.RectangleTexture ;
		setRectangleTexture(name: string, texture: minko.render.RectangleTexture): minko.file.AssetLibrary ;
		textureName(texture: minko.render.AbstractTexture): string ;
		symbol(name: string): minko.scene.Node ;
		setSymbol(name: string, node: minko.scene.Node): minko.file.AssetLibrary ;
		symbolName(node: minko.scene.Node): string ;
		material(name: string): minko.material.Material ;
		setMaterial(name: string, material: minko.material.Material): minko.file.AssetLibrary ;
		materialName(material: minko.material.Material): string ;
		effect(name: string): minko.render.Effect ;
		setEffect(name: string, effect: minko.render.Effect): minko.file.AssetLibrary ;
		effectName(effect: minko.render.Effect): string ;
		hasBlob(name: string): boolean ;
		blob(name: string): haxe.io.Bytes ;
		setBlob(name: string, blob: haxe.io.Bytes): minko.file.AssetLibrary ;
		script(name: string): minko.component.AbstractScript ;
		setScript(name: string, script: minko.component.AbstractScript): minko.file.AssetLibrary ;
		scriptName(script: minko.component.AbstractScript): string ;
		layout(name: string): number ;
		setLayout(name: string, mask: number): minko.file.AssetLibrary ;
		sound(name: string): minko.audio.Sound ;
		setSound(name: string, sound: minko.audio.Sound): minko.file.AssetLibrary ;
		assetDescriptor(name: string): minko.file.AbstractAssetDescriptor ;
		setAssetDescriptor(name: string, assetDescriptor: minko.file.AbstractAssetDescriptor): minko.file.AssetLibrary ;
		static create(context: minko.render.AbstractContext): minko.file.AssetLibrary ;
		static createbyAssetLibrary(original: minko.file.AssetLibrary): minko.file.AssetLibrary ;
	}
}

export namespace minko.file {
	class AssetLocation{
		constructor(filename: string, offset: number, length: number);
		filename: string;
		offset: number;
		length: number;
	}
}

export namespace minko.file {
	class GLSLBlockType{
		private constructor();
		static readonly TEXT: number;
		static readonly FILE: number;
	}
}

export namespace minko.file {
	class GLSLBlockTree{
		constructor(n: minko.Tuple<number, string>);
		node: minko.Tuple<number, string>;
		leaf: minko.file.GLSLBlockTree[];
	}
}

export namespace minko.file {
	class Block<T>{
		constructor();
		bindingMap: T;
		dispose(): void ;
	}
}

export namespace minko.file {
	class AttributeBlock extends minko.file.Block<minko.data.BindingMapBase<minko.data.Binding>>{
		constructor();
		copyFrom(s: minko.file.AttributeBlock): minko.file.AttributeBlock ;
	}
}

export namespace minko.file {
	class MacroBlock extends minko.file.Block<minko.data.MacroBindingMap>{
		constructor();
		copyFrom(s: minko.file.MacroBlock): minko.file.MacroBlock ;
	}
}

export namespace minko.file {
	class UniformBlock extends minko.file.Block<minko.data.BindingMapBase<minko.data.Binding>>{
		constructor();
		copyFrom(s: minko.file.UniformBlock): minko.file.UniformBlock ;
	}
}

export namespace minko.file {
	class StateBlock extends minko.file.Block<minko.data.BindingMapBase<minko.data.Binding>>{
		constructor();
		states: minko.render.States;
		copyFrom(s: minko.file.StateBlock): minko.file.StateBlock ;
	}
}

export namespace minko.file {
	class Scope{
		constructor();
		parent: minko.file.Scope;
		children: minko.file.Scope[];
		attributeBlock: minko.file.AttributeBlock;
		uniformBlock: minko.file.UniformBlock;
		stateBlock: minko.file.StateBlock;
		macroBlock: minko.file.MacroBlock;
		defaultTechnique: string;
		passes: minko.render.Pass[];
		techniques: haxe.ds.StringMap<minko.render.Pass[]>;
		copyFrom(scope: minko.file.Scope): minko.file.Scope ;
		copyFromParent(scope: minko.file.Scope, parent: minko.file.Scope): minko.file.Scope ;
	}
}

export namespace minko.render {
	class Priority{
		private constructor();
		static FIRST: number;
		static BACKGROUND: number;
		static OPAQUE: number;
		static TRANSPARENT: number;
		static LAST: number;
	}
}

export namespace minko.file {
	class EffectParser extends minko.file.AbstractParser{
		constructor();
		readonly effect: minko.render.Effect;
		readonly effectName: string;
		parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: haxe.io.Bytes, assetLibrary: minko.file.AssetLibrary): void ;
		parseTechniques(node: any, scope: minko.file.Scope, techniques: haxe.ds.StringMap<minko.render.Pass[]>): void ;
		parseMacroBindings(node: any, scope: minko.file.Scope, bindings: minko.data.MacroBindingMap): void ;
		parseAttributes(node: any, scope: minko.file.Scope, attributes: minko.file.AttributeBlock): void ;
		parseUniforms(node: any, scope: minko.file.Scope, uniforms: minko.file.UniformBlock): void ;
		parseMacros(node: any, scope: minko.file.Scope, macros: minko.file.MacroBlock): void ;
		createStates(block: minko.file.StateBlock): minko.render.States ;
		concatenateGLSLBlocks(blocks: minko.file.GLSLBlockTree): string ;
		glslIncludeCompleteHandler(loader: minko.file.Loader, blocks: minko.file.GLSLBlockTree, filename: string, includes: string[]): void ;
		static readonly EXTRA_PROPERTY_BLENDING_MODE: string;
		static readonly EXTRA_PROPERTY_STENCIL_TEST: string;
		static readonly EXTRA_PROPERTY_STENCIL_OPS: string;
		static readonly EXTRA_PROPERTY_STENCIL_FAIL_OP: string;
		static readonly EXTRA_PROPERTY_STENCIL_Z_FAIL_OP: string;
		static readonly EXTRA_PROPERTY_STENCIL_Z_PASS_OP: string;
		static create(): minko.file.EffectParser ;
	}
}

export namespace minko.file {
	class File{
		constructor();
		_filename: string;
		_data: haxe.io.Bytes;
		_resolvedFilename: string;
		filename: string;
		resolvedFilename: string;
		readonly data: haxe.io.Bytes;
		static create(): minko.file.File ;
		static getCurrentWorkingDirectory(): string ;
		static getBinaryDirectory(): string ;
		static sanitizeFilename(filename: string): string ;
		static canonizeFilename(filename: string): string ;
		static removePrefixPathFromFilename(filename: string): string ;
		static extractPrefixPathFromFilename(filename: string): string ;
		static getExtension(filename: string): string ;
		static replaceExtension(filename: string, extension: string): string ;
	}
}

export namespace minko.file {
	class FileProtocol extends minko.file.AbstractProtocol{
		constructor();
		load(): void ;
		fileExists(filename: string): boolean ;
		isAbsolutePath(filename: string): boolean ;
		static create(): minko.file.FileProtocol ;
	}
}

export namespace minko.file {
	class JPEGParser extends minko.file.AbstractParser{
		constructor();
		parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: haxe.io.Bytes, assetLibrary: minko.file.AssetLibrary): void ;
		__parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: minko.data.PixelData, assetLibrary: minko.file.AssetLibrary): void ;
	}
}

export namespace minko.file {
	class Loader{
		constructor();
		options: minko.file.Options;
		readonly complete: minko.signal.Signal<minko.file.Loader>;
		readonly progress: minko.signal.Signal2<minko.file.Loader, number>;
		readonly parsingProgress: minko.signal.Signal2<minko.file.Loader, number>;
		readonly error: minko.signal.Signal2<minko.file.Loader, string>;
		readonly filesQueue: string[];
		readonly loading: boolean;
		queue(filename: string): minko.file.Loader ;
		setQueue(filename: string, options: minko.file.Options): minko.file.Loader ;
		load(): void ;
		readonly files: haxe.ds.StringMap<minko.file.File>;
		protocolErrorHandler(protocol: minko.file.AbstractProtocol, err: string): void ;
		protocolCompleteHandler(protocol: minko.file.AbstractProtocol): void ;
		protocolProgressHandler(protocol: minko.file.AbstractProtocol, progress: number): void ;
		finalize(): void ;
		processData(filename: string, resolvedFilename: string, options: minko.file.Options, data: haxe.io.Bytes): boolean ;
		parserProgressHandler(parser: minko.file.AbstractParser, progress: number): void ;
		parserCompleteHandler(parser: minko.file.AbstractParser): void ;
		parserErrorHandler(parser: minko.file.AbstractParser, error: string): void ;
		errorThrown(error: string): void ;
		static create(): minko.file.Loader ;
		static createbyOptions(options: minko.file.Options): minko.file.Loader ;
		static createbyLoader(loader: minko.file.Loader): minko.file.Loader ;
	}
}

export namespace minko.file {
	class MipMapChainParser{
		constructor();
		parseTexture(context: minko.render.AbstractContext, width: number, height: number, data: haxe.io.Bytes, parseMipMaps: boolean, mipMapping?: boolean, smooth?: boolean, format?: number, filename?: string): minko.render.Texture ;
		parseMipMap(_out: haxe.io.Bytes, rgbaOffset: number, data: haxe.io.Bytes, dataOffset: number, width: number, height: number, offset: glm.Vec2Base, mipMapWidth: number, mipMapHeight: number, bytesPerPixel: number): void ;
		parseCubeTexture(context: minko.render.AbstractContext, width: number, height: number, data: haxe.io.Bytes, parseMipMaps: boolean, mipMapping?: boolean, smooth?: boolean, format?: number, filename?: string): minko.render.CubeTexture ;
		dispose(): void ;
	}
}

export namespace minko.file {
	class FileStatus{
		private constructor();
		static readonly Pending: number;
		static readonly Aborted: number;
	}
}

export namespace minko.file {
	class Options{
		constructor();
		clone(): minko.file.Options ;
		context: minko.render.AbstractContext;
		assetLibrary: minko.file.AssetLibrary;
		includePaths: string[];
		readonly platforms: string[];
		readonly userFlags: string[];
		optimizeForRendering: boolean;
		generateMipmaps: boolean;
		parseMipMaps: boolean;
		includeAnimation: boolean;
		startAnimation: boolean;
		loadAsynchronously: boolean;
		resizeSmoothly: boolean;
		isCubeTexture: boolean;
		isRectangleTexture: boolean;
		generateSmoothNormals: boolean;
		normalMaxSmoothingAngle: number;
		disposeIndexBufferAfterLoading: boolean;
		disposeVertexBufferAfterLoading: boolean;
		disposeTextureAfterLoading: boolean;
		storeDataIfNotParsed: boolean;
		preserveMaterials: boolean;
		trackAssetDescriptor: boolean;
		skinningFramerate: number;
		skinningMethod: number;
		effect: minko.render.Effect;
		material: minko.material.Material;
		registerTextureFormat(textureFormat: number): minko.file.Options ;
		protocolFunction: (arg0: string) => () => minko.file.AbstractProtocol;
		parserFunction: (arg0: string) => () => minko.file.AbstractParser;
		materialFunction: (arg0: string, arg1: minko.material.Material) => minko.material.Material;
		textureFunction: (arg0: string, arg1: minko.render.AbstractTexture) => minko.render.AbstractTexture;
		geometryFunction: (arg0: string, arg1: minko.geometry.Geometry) => minko.geometry.Geometry;
		uriFunction: (arg0: string) => string;
		nodeFunction: (arg0: minko.scene.Node) => minko.scene.Node;
		effectFunction: (arg0: minko.render.Effect) => minko.render.Effect;
		textureFormatFunction: (arg0: number[]) => number;
		attributeFunction: (arg0: minko.scene.Node, arg1: string, arg2: string) => void;
		fileStatusFunction: (arg0: minko.file.File, arg1: number) => number;
		preventLoadingFunction: (arg0: string) => boolean;
		seekingOffset: number;
		seekedLength: number;
		registerParser(extension: string, cls: () => minko.file.AbstractParser): minko.file.Options ;
		getParser(extension: string): () => minko.file.AbstractParser ;
		registerProtocol(cls: () => minko.file.AbstractProtocol, protocol: string): minko.file.Options ;
		getProtocol(protocol: string): () => minko.file.AbstractProtocol ;
		copyFrom(copy: minko.file.Options): minko.file.Options ;
		initialize(): void ;
		static empty(): minko.file.Options ;
		static create(context: minko.render.AbstractContext): minko.file.Options ;
		static registerDefaultProtocol(protocol: string, cls: () => minko.file.AbstractProtocol): void ;
		static includePaths_clear(): string[] ;
	}
}

export namespace minko.file {
	class PNGParser extends minko.file.AbstractParser{
		constructor();
		parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: haxe.io.Bytes, assetLibrary: minko.file.AssetLibrary): void ;
		__parse(filename: string, resolvedFilename: string, options: minko.file.Options, data: minko.data.PixelData, assetLibrary: minko.file.AssetLibrary): void ;
	}
}

export namespace minko.geometry {
	class Bone{
		constructor(node: minko.scene.Node, offsetMatrix: glm.Mat4Base, vertexIds: number[], vertexWeights: number[]);
		readonly node: minko.scene.Node;
		readonly offsetMatrix: glm.Mat4Base;
		readonly vertexIds: number[];
		readonly vertexWeights: number[];
		static create(node: minko.scene.Node, offsetMatrix: glm.Mat4Base, vertexIds: number[], vertexWeights: number[]): minko.geometry.Bone ;
	}
}

export namespace minko.geometry {
	class Geometry extends minko.Has_uuid{
		constructor(name: string);
		dispose(): void ;
		clone(): minko.geometry.Geometry ;
		readonly data: minko.data.Provider;
		readonly vertexBuffers: minko.render.VertexBuffer[];
		readonly name: string;
		vertexBuffer(vertexAttributeName: string): minko.render.VertexBuffer ;
		hasVertexBuffer(vertexBuffer: minko.render.VertexBuffer): boolean ;
		hasVertexAttribute(vertexAttributeName: string): boolean ;
		indices: minko.render.IndexBuffer;
		addVertexBuffer(vertexBuffer: minko.render.VertexBuffer): void ;
		removeVertexBuffer(vertexBufferIt: minko.render.VertexBuffer): void ;
		removeVertexBufferbyName(attributeName: string): void ;
		readonly numVertices: number;
		vertexSize: number;
		computeNormals(): minko.geometry.Geometry ;
		computeTangentSpace(doNormals: boolean): minko.geometry.Geometry ;
		computeCenterPosition(): minko.geometry.Geometry ;
		removeDuplicatedVertices(): void ;
		removeDuplicateVertices(indices: number[], vertices: number[][], numVertices: number): void ;
		getVertexAttribute(attributeName: string): minko.render.VertexAttribute ;
		castRay(ray: minko.math.Ray, distance: number, triangle: number, hitXyz?: glm.Vec3Base, hitUv?: glm.Vec2Base, hitNormal?: glm.Vec3Base): boolean ;
		upload(): void ;
		disposeIndexBufferData(): void ;
		disposeVertexBufferData(): void ;
		copyFrom(geometry: minko.geometry.Geometry): minko.geometry.Geometry ;
		vertexSizeChanged(vertexBuffer: minko.render.VertexBuffer, offset: number): void ;
		static createbyName(name: string): minko.geometry.Geometry ;
	}
}

export namespace minko.geometry {
	class CubeGeometry extends minko.geometry.Geometry{
		constructor();
		static create(context: minko.render.AbstractContext): minko.geometry.CubeGeometry ;
	}
}

export namespace minko.geometry {
	class LineGeometry extends minko.geometry.Geometry{
		constructor();
		readonly currentXYZ: glm.Vec3Base;
		readonly numLines: number;
		moveTo(x: number, y: number, z: number): minko.geometry.LineGeometry ;
		moveToVector3(xyz: glm.Vec3Base): minko.geometry.LineGeometry ;
		lineTo(x: number, y: number, z: number, numSegments?: number): minko.geometry.LineGeometry ;
		lineToVector3(xyz: glm.Vec3Base, numSegments?: number): minko.geometry.LineGeometry ;
		upload(): void ;
		static readonly MAX_NUM_LINES: number;
		static readonly ATTRNAME_START_POS: string;
		static readonly ATTRNAME_STOP_POS: string;
		static readonly ATTRNAME_WEIGHTS: string;
		static create(context: minko.render.AbstractContext): minko.geometry.LineGeometry ;
	}
}

export namespace minko.geometry {
	class QuadGeometry extends minko.geometry.Geometry{
		constructor(numColumns: number, numRows?: number, width?: number, height?: number);
		static create(context: minko.render.AbstractContext, numColumns?: number, numRows?: number, width?: number, height?: number): minko.geometry.QuadGeometry ;
	}
}

export namespace minko.geometry {
	class Skin{
		constructor(numBones: number, duration?: number, numFrames?: number);
		clone(): minko.geometry.Skin ;
		readonly numBones: number;
		readonly maxNumVertexBones: number;
		bones: minko.geometry.Bone[];
		getBone(boneId: number): minko.geometry.Bone ;
		setBone(boneId: number, value: minko.geometry.Bone): void ;
		readonly duration: number;
		getFrameId(time: number): number ;
		readonly numFrames: number;
		boneMatricesPerFrame: glm.Mat4Base[][];
		set_boneMatricesPerFrame(v: glm.Mat4Base[][]): glm.Mat4Base[][] ;
		get_boneMatricesPerFrame(): glm.Mat4Base[][] ;
		getMatrices(frameId: number): glm.Mat4Base[] ;
		setMatrix(frameId: number, boneId: number, value: glm.Mat4Base): void ;
		readonly numVertices: number;
		numVertexBones(vertexId: number): number ;
		vertexBoneData(vertexId: number, j: number, boneId: number, boneWeight: number): void ;
		vertexBoneId(vertexId: number, j: number): number ;
		vertexBoneWeight(vertexId: number, j: number): number ;
		reorganizeByVertices(): minko.geometry.Skin ;
		disposeBones(): minko.geometry.Skin ;
		copyFrom(skin: minko.geometry.Skin): minko.geometry.Skin ;
		readonly lastVertexId: number;
		static create(numBones: number, duration: number, numFrames: number): minko.geometry.Skin ;
	}
}

export namespace minko.geometry {
	class SphereGeometry extends minko.geometry.Geometry{
		constructor();
		static create(context: minko.render.AbstractContext, numParallels?: number, numMeridians?: number, withNormals?: boolean): minko.geometry.SphereGeometry ;
	}
}

export namespace minko.geometry {
	class TeapotGeometry extends minko.geometry.Geometry{
		constructor();
		static create(context: minko.render.AbstractContext, divs?: number): minko.geometry.TeapotGeometry ;
	}
}

export namespace minko.input {
	class Button{
		private constructor();
		static readonly Nothing: number;
		static readonly DPadUp: number;
		static readonly DPadDown: number;
		static readonly DPadLeft: number;
		static readonly DPadRight: number;
		static readonly Start: number;
		static readonly Select: number;
		static readonly L3: number;
		static readonly R3: number;
		static readonly LB: number;
		static readonly RB: number;
		static readonly A: number;
		static readonly B: number;
		static readonly X: number;
		static readonly Y: number;
		static readonly Home: number;
		static readonly LT: number;
		static readonly RT: number;
	}
}

export namespace minko.input {
	class Joystick{
		constructor(canvas: minko.AbstractCanvas, joystickId: number);
		readonly joystickId: number;
		readonly joystickAxisMotion: minko.signal.Signal4<minko.input.Joystick, number, number, number>;
		readonly joystickHatMotion: minko.signal.Signal4<minko.input.Joystick, number, number, number>;
		readonly joystickButtonDown: minko.signal.Signal3<minko.input.Joystick, number, number>;
		readonly joystickButtonUp: minko.signal.Signal3<minko.input.Joystick, number, number>;
	}
}

export namespace minko.input {
	class KeyType{
		private constructor();
		static readonly TKeyCode: number;
		static readonly TScanCode: number;
	}
}

export namespace minko.input {
	class Key{
		private constructor();
		static readonly CANCEL: number;
		static readonly HELP: number;
		static readonly BACK_SPACE: number;
		static readonly TAB: number;
		static readonly CLEAR: number;
		static readonly RETURN: number;
		static readonly ENTER: number;
		static readonly SHIFT: number;
		static readonly CONTROL: number;
		static readonly ALT: number;
		static readonly PAUSE: number;
		static readonly CAPS_LOCK: number;
		static readonly KANA: number;
		static readonly EISU: number;
		static readonly JUNJA: number;
		static readonly FINAL: number;
		static readonly KANJI: number;
		static readonly ESCAPE: number;
		static readonly CONVERT: number;
		static readonly NONCONVERT: number;
		static readonly ACCEPT: number;
		static readonly MODECHANGE: number;
		static readonly SPACE: number;
		static readonly PAGE_UP: number;
		static readonly PAGE_DOWN: number;
		static readonly END: number;
		static readonly HOME: number;
		static readonly LEFT: number;
		static readonly UP: number;
		static readonly RIGHT: number;
		static readonly DOWN: number;
		static readonly SELECT: number;
		static readonly PRINT: number;
		static readonly EXECUTE: number;
		static readonly PRINTSCREEN: number;
		static readonly INSERT: number;
		static readonly DEL: number;
		static readonly _0: number;
		static readonly _1: number;
		static readonly _2: number;
		static readonly _3: number;
		static readonly _4: number;
		static readonly _5: number;
		static readonly _6: number;
		static readonly _7: number;
		static readonly _8: number;
		static readonly _9: number;
		static readonly COLON: number;
		static readonly SEMICOLON: number;
		static readonly LESS_THAN: number;
		static readonly EQUALS: number;
		static readonly GREATER_THAN: number;
		static readonly QUESTION_MARK: number;
		static readonly AT: number;
		static readonly A: number;
		static readonly B: number;
		static readonly C: number;
		static readonly D: number;
		static readonly E: number;
		static readonly F: number;
		static readonly G: number;
		static readonly H: number;
		static readonly I: number;
		static readonly J: number;
		static readonly K: number;
		static readonly L: number;
		static readonly M: number;
		static readonly N: number;
		static readonly O: number;
		static readonly P: number;
		static readonly Q: number;
		static readonly R: number;
		static readonly S: number;
		static readonly T: number;
		static readonly U: number;
		static readonly V: number;
		static readonly W: number;
		static readonly X: number;
		static readonly Y: number;
		static readonly Z: number;
		static readonly WIN: number;
		static readonly CONTEXT_MENU: number;
		static readonly SLEEP: number;
		static readonly NUMPAD0: number;
		static readonly NUMPAD1: number;
		static readonly NUMPAD2: number;
		static readonly NUMPAD3: number;
		static readonly NUMPAD4: number;
		static readonly NUMPAD5: number;
		static readonly NUMPAD6: number;
		static readonly NUMPAD7: number;
		static readonly NUMPAD8: number;
		static readonly NUMPAD9: number;
		static readonly MULTIPLY: number;
		static readonly ADD: number;
		static readonly SEPARATOR: number;
		static readonly SUBTRACT: number;
		static readonly DECIMAL: number;
		static readonly DIVIDE: number;
		static readonly F1: number;
		static readonly F2: number;
		static readonly F3: number;
		static readonly F4: number;
		static readonly F5: number;
		static readonly F6: number;
		static readonly F7: number;
		static readonly F8: number;
		static readonly F9: number;
		static readonly F10: number;
		static readonly F11: number;
		static readonly F12: number;
		static readonly F13: number;
		static readonly F14: number;
		static readonly F15: number;
		static readonly F16: number;
		static readonly F17: number;
		static readonly F18: number;
		static readonly F19: number;
		static readonly F20: number;
		static readonly F21: number;
		static readonly F22: number;
		static readonly F23: number;
		static readonly F24: number;
		static readonly NUM_LOCK: number;
		static readonly SCROLL_LOCK: number;
		static readonly WIN_OEM_FJ_JISHO: number;
		static readonly WIN_OEM_FJ_MASSHOU: number;
		static readonly WIN_OEM_FJ_TOUROKU: number;
		static readonly WIN_OEM_FJ_LOYA: number;
		static readonly WIN_OEM_FJ_ROYA: number;
		static readonly CIRCUMFLEX: number;
		static readonly EXCLAMATION: number;
		static readonly DOUBLE_QUOTE: number;
		static readonly HASH: number;
		static readonly DOLLAR: number;
		static readonly PERCENT: number;
		static readonly AMPERSAND: number;
		static readonly UNDERSCORE: number;
		static readonly OPEN_PAREN: number;
		static readonly CLOSE_PAREN: number;
		static readonly ASTERISK: number;
		static readonly PLUS: number;
		static readonly PIPE: number;
		static readonly HYPHEN_MINUS: number;
		static readonly OPEN_CURLY_BRACKET: number;
		static readonly CLOSE_CURLY_BRACKET: number;
		static readonly TILDE: number;
		static readonly VOLUME_MUTE: number;
		static readonly VOLUME_DOWN: number;
		static readonly VOLUME_UP: number;
		static readonly COMMA: number;
		static readonly PERIOD: number;
		static readonly SLASH: number;
		static readonly BACK_QUOTE: number;
		static readonly OPEN_BRACKET: number;
		static readonly BACK_SLASH: number;
		static readonly CLOSE_BRACKET: number;
		static readonly QUOTE: number;
		static readonly META: number;
		static readonly ALTGR: number;
		static readonly WIN_ICO_HELP: number;
		static readonly WIN_ICO_00: number;
		static readonly WIN_ICO_CLEAR: number;
		static readonly WIN_OEM_RESET: number;
		static readonly WIN_OEM_JUMP: number;
		static readonly WIN_OEM_PA1: number;
		static readonly WIN_OEM_PA2: number;
		static readonly WIN_OEM_PA3: number;
		static readonly WIN_OEM_WSCTRL: number;
		static readonly WIN_OEM_CUSEL: number;
		static readonly WIN_OEM_ATTN: number;
		static readonly WIN_OEM_FINISH: number;
		static readonly WIN_OEM_COPY: number;
		static readonly WIN_OEM_AUTO: number;
		static readonly WIN_OEM_ENLW: number;
		static readonly WIN_OEM_BACKTAB: number;
		static readonly ATTN: number;
		static readonly CRSEL: number;
		static readonly EXSEL: number;
		static readonly EREOF: number;
		static readonly PLAY: number;
		static readonly ZOOM: number;
		static readonly PA1: number;
		static readonly WIN_OEM_CLEAR: number;
		static readonly CONTROL_RIGHT: number;
		static readonly SHIFT_RIGHT: number;
	}
}

export namespace minko.input {
	class ScanCode{
		private constructor();
		static readonly UNKNOWN: number;
		static readonly A: number;
		static readonly B: number;
		static readonly C: number;
		static readonly D: number;
		static readonly E: number;
		static readonly F: number;
		static readonly G: number;
		static readonly H: number;
		static readonly I: number;
		static readonly J: number;
		static readonly K: number;
		static readonly L: number;
		static readonly M: number;
		static readonly N: number;
		static readonly O: number;
		static readonly P: number;
		static readonly Q: number;
		static readonly R: number;
		static readonly S: number;
		static readonly T: number;
		static readonly U: number;
		static readonly V: number;
		static readonly W: number;
		static readonly X: number;
		static readonly Y: number;
		static readonly Z: number;
		static readonly _1: number;
		static readonly _2: number;
		static readonly _3: number;
		static readonly _4: number;
		static readonly _5: number;
		static readonly _6: number;
		static readonly _7: number;
		static readonly _8: number;
		static readonly _9: number;
		static readonly _0: number;
		static readonly RETURN: number;
		static readonly ESCAPE: number;
		static readonly BACKSPACE: number;
		static readonly TAB: number;
		static readonly SPACE: number;
		static readonly MINUS: number;
		static readonly EQUALS: number;
		static readonly LEFTBRACKET: number;
		static readonly RIGHTBRACKET: number;
		static readonly BACKSLASH: number;
		static readonly NONUSHASH: number;
		static readonly SEMICOLON: number;
		static readonly APOSTROPHE: number;
		static readonly GRAVE: number;
		static readonly COMMA: number;
		static readonly PERIOD: number;
		static readonly SLASH: number;
		static readonly CAPSLOCK: number;
		static readonly F1: number;
		static readonly F2: number;
		static readonly F3: number;
		static readonly F4: number;
		static readonly F5: number;
		static readonly F6: number;
		static readonly F7: number;
		static readonly F8: number;
		static readonly F9: number;
		static readonly F10: number;
		static readonly F11: number;
		static readonly F12: number;
		static readonly PRINTSCREEN: number;
		static readonly SCROLLLOCK: number;
		static readonly PAUSE: number;
		static readonly INSERT: number;
		static readonly HOME: number;
		static readonly PAGEUP: number;
		static readonly DEL: number;
		static readonly END: number;
		static readonly PAGEDOWN: number;
		static readonly RIGHT: number;
		static readonly LEFT: number;
		static readonly DOWN: number;
		static readonly UP: number;
		static readonly NUMLOCKCLEAR: number;
		static readonly KP_DIVIDE: number;
		static readonly KP_MULTIPLY: number;
		static readonly KP_MINUS: number;
		static readonly KP_PLUS: number;
		static readonly KP_ENTER: number;
		static readonly KP_1: number;
		static readonly KP_2: number;
		static readonly KP_3: number;
		static readonly KP_4: number;
		static readonly KP_5: number;
		static readonly KP_6: number;
		static readonly KP_7: number;
		static readonly KP_8: number;
		static readonly KP_9: number;
		static readonly KP_0: number;
		static readonly KP_PERIOD: number;
		static readonly NONUSBACKSLASH: number;
		static readonly APPLICATION: number;
		static readonly POWER: number;
		static readonly KP_EQUALS: number;
		static readonly F13: number;
		static readonly F14: number;
		static readonly F15: number;
		static readonly F16: number;
		static readonly F17: number;
		static readonly F18: number;
		static readonly F19: number;
		static readonly F20: number;
		static readonly F21: number;
		static readonly F22: number;
		static readonly F23: number;
		static readonly F24: number;
		static readonly EXECUTE: number;
		static readonly HELP: number;
		static readonly MENU: number;
		static readonly SELECT: number;
		static readonly STOP: number;
		static readonly AGAIN: number;
		static readonly UNDO: number;
		static readonly CUT: number;
		static readonly COPY: number;
		static readonly PASTE: number;
		static readonly FIND: number;
		static readonly MUTE: number;
		static readonly VOLUMEUP: number;
		static readonly VOLUMEDOWN: number;
		static readonly KP_COMMA: number;
		static readonly KP_EQUALSAS400: number;
		static readonly INTERNATIONAL1: number;
		static readonly INTERNATIONAL2: number;
		static readonly INTERNATIONAL3: number;
		static readonly INTERNATIONAL4: number;
		static readonly INTERNATIONAL5: number;
		static readonly INTERNATIONAL6: number;
		static readonly INTERNATIONAL7: number;
		static readonly INTERNATIONAL8: number;
		static readonly INTERNATIONAL9: number;
		static readonly LANG1: number;
		static readonly LANG2: number;
		static readonly LANG3: number;
		static readonly LANG4: number;
		static readonly LANG5: number;
		static readonly LANG6: number;
		static readonly LANG7: number;
		static readonly LANG8: number;
		static readonly LANG9: number;
		static readonly ALTERASE: number;
		static readonly SYSREQ: number;
		static readonly CANCEL: number;
		static readonly CLEAR: number;
		static readonly PRIOR: number;
		static readonly RETURN2: number;
		static readonly SEPARATOR: number;
		static readonly OPER: number;
		static readonly CLEARAGAIN: number;
		static readonly CRSEL: number;
		static readonly EXSEL: number;
		static readonly KP_00: number;
		static readonly KP_000: number;
		static readonly THOUSANDSSEPARATOR: number;
		static readonly DECIMALSEPARATOR: number;
		static readonly CURRENCYUNIT: number;
		static readonly CURRENCYSUBUNIT: number;
		static readonly KP_LEFTPAREN: number;
		static readonly KP_RIGHTPAREN: number;
		static readonly KP_LEFTBRACE: number;
		static readonly KP_RIGHTBRACE: number;
		static readonly KP_TAB: number;
		static readonly KP_BACKSPACE: number;
		static readonly KP_A: number;
		static readonly KP_B: number;
		static readonly KP_C: number;
		static readonly KP_D: number;
		static readonly KP_E: number;
		static readonly KP_F: number;
		static readonly KP_XOR: number;
		static readonly KP_POWER: number;
		static readonly KP_PERCENT: number;
		static readonly KP_LESS: number;
		static readonly KP_GREATER: number;
		static readonly KP_AMPERSAND: number;
		static readonly KP_DBLAMPERSAND: number;
		static readonly KP_VERTICALBAR: number;
		static readonly KP_DBLVERTICALBAR: number;
		static readonly KP_COLON: number;
		static readonly KP_HASH: number;
		static readonly KP_SPACE: number;
		static readonly KP_AT: number;
		static readonly KP_EXCLAM: number;
		static readonly KP_MEMSTORE: number;
		static readonly KP_MEMRECALL: number;
		static readonly KP_MEMCLEAR: number;
		static readonly KP_MEMADD: number;
		static readonly KP_MEMSUBTRACT: number;
		static readonly KP_MEMMULTIPLY: number;
		static readonly KP_MEMDIVIDE: number;
		static readonly KP_PLUSMINUS: number;
		static readonly KP_CLEAR: number;
		static readonly KP_CLEARENTRY: number;
		static readonly KP_BINARY: number;
		static readonly KP_OCTAL: number;
		static readonly KP_DECIMAL: number;
		static readonly KP_HEXADECIMAL: number;
		static readonly LCTRL: number;
		static readonly LSHIFT: number;
		static readonly LALT: number;
		static readonly LGUI: number;
		static readonly RCTRL: number;
		static readonly RSHIFT: number;
		static readonly RALT: number;
		static readonly RGUI: number;
		static readonly MODE: number;
		static readonly AUDIONEXT: number;
		static readonly AUDIOPREV: number;
		static readonly AUDIOSTOP: number;
		static readonly AUDIOPLAY: number;
		static readonly AUDIOMUTE: number;
		static readonly MEDIASELECT: number;
		static readonly WWW: number;
		static readonly MAIL: number;
		static readonly CALCULATOR: number;
		static readonly COMPUTER: number;
		static readonly AC_SEARCH: number;
		static readonly AC_HOME: number;
		static readonly AC_BACK: number;
		static readonly AC_FORWARD: number;
		static readonly AC_STOP: number;
		static readonly AC_REFRESH: number;
		static readonly AC_BOOKMARKS: number;
		static readonly BRIGHTNESSDOWN: number;
		static readonly BRIGHTNESSUP: number;
		static readonly DISPLAYSWITCH: number;
		static readonly KBDILLUMTOGGLE: number;
		static readonly KBDILLUMDOWN: number;
		static readonly KBDILLUMUP: number;
		static readonly EJECT: number;
		static readonly SLEEP: number;
		static readonly APP1: number;
		static readonly APP2: number;
	}
}

export namespace minko.input {
	class KeyCode{
		private constructor();
		static readonly UNKNOWN: number;
		static readonly FIRST: number;
		static readonly BACKSPACE: number;
		static readonly TAB: number;
		static readonly CLEAR: number;
		static readonly RETURN: number;
		static readonly PAUSE: number;
		static readonly CANCEL: number;
		static readonly ESCAPE: number;
		static readonly FS: number;
		static readonly GS: number;
		static readonly RS: number;
		static readonly US: number;
		static readonly SPACE: number;
		static readonly EXCLAIM: number;
		static readonly QUOTEDBL: number;
		static readonly HASH: number;
		static readonly DOLLAR: number;
		static readonly PERCENT: number;
		static readonly AMPERSAND: number;
		static readonly QUOTE: number;
		static readonly LEFTPAREN: number;
		static readonly RIGHTPAREN: number;
		static readonly ASTERISK: number;
		static readonly PLUS: number;
		static readonly COMMA: number;
		static readonly MINUS: number;
		static readonly PERIOD: number;
		static readonly SLASH: number;
		static readonly _0: number;
		static readonly _1: number;
		static readonly _2: number;
		static readonly _3: number;
		static readonly _4: number;
		static readonly _5: number;
		static readonly _6: number;
		static readonly _7: number;
		static readonly _8: number;
		static readonly _9: number;
		static readonly COLON: number;
		static readonly SEMICOLON: number;
		static readonly LESS: number;
		static readonly EQUALS: number;
		static readonly GREATER: number;
		static readonly QUESTION: number;
		static readonly AT: number;
		static readonly LEFTBRACKET: number;
		static readonly BACKSLASH: number;
		static readonly RIGHTBRACKET: number;
		static readonly CARET: number;
		static readonly UNDERSCORE: number;
		static readonly BACKQUOTE: number;
		static readonly A: number;
		static readonly B: number;
		static readonly C: number;
		static readonly D: number;
		static readonly E: number;
		static readonly F: number;
		static readonly G: number;
		static readonly H: number;
		static readonly I: number;
		static readonly J: number;
		static readonly K: number;
		static readonly L: number;
		static readonly M: number;
		static readonly N: number;
		static readonly O: number;
		static readonly P: number;
		static readonly Q: number;
		static readonly R: number;
		static readonly S: number;
		static readonly T: number;
		static readonly U: number;
		static readonly V: number;
		static readonly W: number;
		static readonly X: number;
		static readonly Y: number;
		static readonly Z: number;
		static readonly LEFTCURLYBRACKET: number;
		static readonly PIPE: number;
		static readonly RIGHTCURLYBRACKET: number;
		static readonly TILDE: number;
		static readonly DEL: number;
		static readonly WORLD_0: number;
		static readonly WORLD_1: number;
		static readonly WORLD_2: number;
		static readonly WORLD_3: number;
		static readonly WORLD_4: number;
		static readonly WORLD_5: number;
		static readonly WORLD_6: number;
		static readonly WORLD_7: number;
		static readonly WORLD_8: number;
		static readonly WORLD_9: number;
		static readonly WORLD_10: number;
		static readonly WORLD_11: number;
		static readonly WORLD_12: number;
		static readonly WORLD_13: number;
		static readonly WORLD_14: number;
		static readonly WORLD_15: number;
		static readonly WORLD_16: number;
		static readonly WORLD_17: number;
		static readonly WORLD_18: number;
		static readonly WORLD_19: number;
		static readonly WORLD_20: number;
		static readonly WORLD_21: number;
		static readonly WORLD_22: number;
		static readonly WORLD_23: number;
		static readonly WORLD_24: number;
		static readonly WORLD_25: number;
		static readonly WORLD_26: number;
		static readonly WORLD_27: number;
		static readonly WORLD_28: number;
		static readonly WORLD_29: number;
		static readonly WORLD_30: number;
		static readonly WORLD_31: number;
		static readonly WORLD_32: number;
		static readonly WORLD_33: number;
		static readonly WORLD_34: number;
		static readonly WORLD_35: number;
		static readonly WORLD_36: number;
		static readonly WORLD_37: number;
		static readonly WORLD_38: number;
		static readonly WORLD_39: number;
		static readonly WORLD_40: number;
		static readonly WORLD_41: number;
		static readonly WORLD_42: number;
		static readonly WORLD_43: number;
		static readonly WORLD_44: number;
		static readonly WORLD_45: number;
		static readonly WORLD_46: number;
		static readonly WORLD_47: number;
		static readonly WORLD_48: number;
		static readonly WORLD_49: number;
		static readonly WORLD_50: number;
		static readonly WORLD_51: number;
		static readonly WORLD_52: number;
		static readonly WORLD_53: number;
		static readonly WORLD_54: number;
		static readonly WORLD_55: number;
		static readonly WORLD_56: number;
		static readonly WORLD_57: number;
		static readonly WORLD_58: number;
		static readonly WORLD_59: number;
		static readonly WORLD_60: number;
		static readonly WORLD_61: number;
		static readonly WORLD_62: number;
		static readonly WORLD_63: number;
		static readonly WORLD_64: number;
		static readonly WORLD_65: number;
		static readonly WORLD_66: number;
		static readonly WORLD_67: number;
		static readonly WORLD_68: number;
		static readonly WORLD_69: number;
		static readonly WORLD_70: number;
		static readonly WORLD_71: number;
		static readonly WORLD_72: number;
		static readonly WORLD_73: number;
		static readonly WORLD_74: number;
		static readonly WORLD_75: number;
		static readonly WORLD_76: number;
		static readonly WORLD_77: number;
		static readonly WORLD_78: number;
		static readonly WORLD_79: number;
		static readonly WORLD_80: number;
		static readonly WORLD_81: number;
		static readonly WORLD_82: number;
		static readonly WORLD_83: number;
		static readonly WORLD_84: number;
		static readonly WORLD_85: number;
		static readonly WORLD_86: number;
		static readonly WORLD_87: number;
		static readonly WORLD_88: number;
		static readonly WORLD_89: number;
		static readonly WORLD_90: number;
		static readonly WORLD_91: number;
		static readonly WORLD_92: number;
		static readonly WORLD_93: number;
		static readonly WORLD_94: number;
		static readonly WORLD_95: number;
	}
}

export namespace minko.input {
	class KeyMap{
		private constructor();
		static keyToKeyCodeMap: haxe.ds.IntMap<number>;
		static keyToScanCodeMap: haxe.ds.IntMap<number>;
		static initializeKeyToKeyCodeMap(): haxe.ds.IntMap<number> ;
		static initializeKeyToScanCodeMap(): haxe.ds.IntMap<number> ;
	}
}

export namespace minko.input {
	class Keyboard{
		constructor();
		readonly keyDown: minko.signal.Signal<minko.input.Keyboard>;
		readonly textInput: minko.signal.Signal2<minko.input.Keyboard, number>;
		getKeyDown(key: number): minko.signal.Signal2<minko.input.Keyboard, number> ;
		readonly keyUp: minko.signal.Signal<minko.input.Keyboard>;
		getKeyUp(key: number): minko.signal.Signal2<minko.input.Keyboard, number> ;
		keyIsDown(key: number): boolean ;
		hasKeyDownSignal(key: number): boolean ;
		hasKeyUpSignal(key: number): boolean ;
		setKeyboardState(key: number, state: number): void ;
		static create(): minko.input.Keyboard ;
		static NUM_KEYS: number;
		static getKeyName(key: number): string ;
	}
}

export namespace minko.input {
	class Mouse{
		constructor(canvas: minko.AbstractCanvas);
		x: number;
		y: number;
		dX: number;
		dY: number;
		readonly leftButtonIsDown: boolean;
		readonly rightButtonIsDown: boolean;
		readonly middleButtonIsDown: boolean;
		readonly normalizedX: number;
		readonly normalizedY: number;
		readonly move: minko.signal.Signal3<minko.input.Mouse, number, number>;
		readonly wheel: minko.signal.Signal3<minko.input.Mouse, number, number>;
		readonly leftButtonDown: minko.signal.Signal<minko.input.Mouse>;
		readonly leftButtonUp: minko.signal.Signal<minko.input.Mouse>;
		readonly leftButtonClick: minko.signal.Signal<minko.input.Mouse>;
		readonly rightButtonDown: minko.signal.Signal<minko.input.Mouse>;
		readonly rightButtonUp: minko.signal.Signal<minko.input.Mouse>;
		readonly rightButtonClick: minko.signal.Signal<minko.input.Mouse>;
		readonly middleButtonDown: minko.signal.Signal<minko.input.Mouse>;
		readonly middleButtonUp: minko.signal.Signal<minko.input.Mouse>;
		readonly middleButtonClick: minko.signal.Signal<minko.input.Mouse>;
		static create(canvas: minko.AbstractCanvas): minko.input.Mouse ;
		static readonly CLICK_MOVE_THRESHOLD: number;
	}
}

export namespace minko.input {
	class TouchPoint{
		constructor(x: number, y: number, dX: number, dY: number);
		x: number;
		y: number;
		dX: number;
		dY: number;
	}
}

export namespace minko.input {
	class Touch{
		constructor(canvas: minko.AbstractCanvas);
		readonly touches: haxe.ds.IntMap<minko.input.TouchPoint>;
		readonly identifiers: number[];
		readonly numTouches: number;
		touch(identifier: number): minko.input.TouchPoint ;
		readonly touchMove: minko.signal.Signal4<minko.input.Touch, number, number, number>;
		readonly touchDown: minko.signal.Signal4<minko.input.Touch, number, number, number>;
		readonly touchUp: minko.signal.Signal4<minko.input.Touch, number, number, number>;
		readonly swipeLeft: minko.signal.Signal<minko.input.Touch>;
		readonly swipeRight: minko.signal.Signal<minko.input.Touch>;
		readonly swipeUp: minko.signal.Signal<minko.input.Touch>;
		readonly swipeDown: minko.signal.Signal<minko.input.Touch>;
		readonly pinchZoom: minko.signal.Signal2<minko.input.Touch, number>;
		readonly tap: minko.signal.Signal3<minko.input.Touch, number, number>;
		readonly doubleTap: minko.signal.Signal3<minko.input.Touch, number, number>;
		readonly longHold: minko.signal.Signal3<minko.input.Touch, number, number>;
		readonly averageX: number;
		readonly averageY: number;
		readonly averageDX: number;
		readonly averageDY: number;
		resetDeltas(): void ;
		addTouch(identifier: number, x: number, y: number, dX: number, dY: number): void ;
		updateTouch(identifier: number, x: number, y: number, dX: number, dY: number): void ;
		removeTouch(identifier: number): void ;
		static create(canvas: minko.AbstractCanvas): minko.input.Touch ;
	}
}

export namespace minko.material {
	class Material extends minko.Has_uuid{
		constructor(name: string);
		dispose(): void ;
		readonly name: string;
		readonly data: minko.data.Provider;
		hasProperty(propertyName: string): boolean ;
		get(propertyName: string): any ;
		unset(propertyName: string): void ;
		setbyKeyObject(values: any): minko.material.Material ;
		set(key: string, values: any): minko.material.Material ;
		copyFrom(values: minko.data.Provider): void ;
		initialize(): void ;
		static create(name: string): minko.material.Material ;
		static createbyMaterial(source: minko.material.Material): minko.material.Material ;
	}
}

export namespace minko.material {
	class BasicMaterial extends minko.material.Material{
		constructor(name: string);
		diffuseColor: glm.Vec4Base;
		diffuseColorRGBA(diffuseRGBA: number): glm.Vec4Base ;
		uvScale: glm.Vec2Base;
		uvOffset: glm.Vec2Base;
		diffuseMap: minko.render.AbstractTexture;
		fogColor: glm.Vec4Base;
		fogColorRGBA(fogRGBA: number): glm.Vec4Base ;
		fogStart: number;
		fogEnd: number;
		fogTechnique: number;
		setBlendingMode(src: number, dst: number): minko.material.BasicMaterial ;
		blendingMode: number;
		readonly blendingSourceFactor: number;
		readonly blendingDestinationFactor: number;
		colorMask: boolean;
		depthMask: boolean;
		depthFunction: number;
		triangleCulling: number;
		stencilFunction: number;
		stencilReference: number;
		stencilMask: number;
		stencilFailOperation: number;
		stencilZFailOperation: number;
		stencilZPassOperation: number;
		priority: number;
		zSorted: boolean;
		static create(name: string): minko.material.BasicMaterial ;
		static createbyBasicMaterial(source: minko.material.BasicMaterial): minko.material.Material ;
	}
}

export namespace minko.material {
	class FogTechnique{
		private constructor();
		static readonly LIN: number;
		static readonly EXP: number;
		static readonly EXP2: number;
	}
}

export namespace minko.material {
	class PhongMaterial extends minko.material.BasicMaterial{
		constructor(name: string);
		specularColor: glm.Vec4Base;
		specularColorRGBA(color: number): glm.Vec4Base ;
		shininess: number;
		normalMap: minko.render.AbstractTexture;
		specularMap: minko.render.AbstractTexture;
		environmentAlpha: number;
		readonly environmentCubemap: minko.render.AbstractTexture;
		environmentMap: minko.render.AbstractTexture;
		readonly environmentMap2d: minko.render.AbstractTexture;
		readonly alphaMap: minko.render.AbstractTexture;
		alphaThreshold: number;
		fresnelReflectance: number;
		fresnelExponent: number;
		static create(name: string): minko.material.PhongMaterial ;
		static createbyPhongMaterial(source: minko.material.PhongMaterial): minko.material.PhongMaterial ;
	}
}

export namespace minko.material {
	class WaterMaterial extends minko.material.PhongMaterial{
		constructor(numWaves: number, name: string);
		setDirection(waveId: number, direction: glm.Vec2Base): minko.material.WaterMaterial ;
		setCenter(waveId: number, origin: glm.Vec2Base): minko.material.WaterMaterial ;
		setAmplitude(waveId: number, amplitude: number): minko.material.WaterMaterial ;
		setWaveLength(waveId: number, waveLength: number): minko.material.WaterMaterial ;
		setSharpness(waveId: number, sharpness: number): minko.material.WaterMaterial ;
		setSpeed(waveId: number, speed: number): minko.material.WaterMaterial ;
		static createWaves(numWaves: number, name?: string): minko.material.WaterMaterial ;
	}
}

export namespace minko.math {
	class ShapePosition{
		private constructor();
		static readonly AROUND: number;
		static readonly INSIDE: number;
		static readonly LEFT: number;
		static readonly TOP: number;
		static readonly RIGHT: number;
		static readonly BOTTOM: number;
		static readonly NEAR: number;
		static readonly FAR: number;
	}
}

export namespace minko.math {
	class PlanePosition{
		private constructor();
		static readonly LEFT: number;
		static readonly TOP: number;
		static readonly RIGHT: number;
		static readonly BOTTOM: number;
		static readonly NEAR: number;
		static readonly FAR: number;
	}
}

export namespace minko.math {
	class AbstractShape{
		constructor();
		castRay(ray: minko.math.Ray, distance: number): boolean ;
		testBoundingBox(box: minko.math.Box): number ;
		testBoundingBoxandPlane(box: minko.math.Box, basePlaneId: number): minko.Tuple<number, number> ;
		updateFromMatrix(matrix: glm.Mat4Base): void ;
	}
}

export namespace minko.math {
	class Box extends minko.math.AbstractShape{
		constructor();
		mergeBox(box2: minko.math.Box): minko.math.Box ;
		topRight: glm.Vec3Base;
		bottomLeft: glm.Vec3Base;
		readonly width: number;
		readonly height: number;
		readonly depth: number;
		copyFrom(box: minko.math.Box): minko.math.Box ;
		distance(position: glm.Vec3Base): number ;
		castRay(ray: minko.math.Ray, distance: number): boolean ;
		getVertices(): glm.Vec3Base[] ;
		testBoundingBox(box: minko.math.Box): number ;
		updateFromMatrix(matrix: glm.Mat4Base): void ;
		static create(): minko.math.Box ;
		static createbyVector3(topRight: glm.Vec3Base, bottomLeft: glm.Vec3Base): minko.math.Box ;
		static merge(box1: minko.math.Box, box2: minko.math.Box, out?: minko.math.Box): minko.math.Box ;
	}
}

export namespace minko.math {
	class Frustum extends minko.math.AbstractShape{
		constructor();
		castRay(ray: minko.math.Ray, distance: number): boolean ;
		updateFromMatrix(matrix: glm.Mat4Base): void ;
		testBoundingBox(box: minko.math.Box): number ;
		testBoundingBoxandPlane(box: minko.math.Box, basePlaneId: number): minko.Tuple<number, number> ;
		static create(): minko.math.Frustum ;
	}
}

export namespace minko.math {
	class NodeEntry{
		constructor(node: minko.scene.Node, box: minko.math.Box);
		node: minko.scene.Node;
		box: minko.math.Box;
	}
}

export namespace minko.math {
	class OctTree{
		constructor(worldSize: number, maxDepth: number, center: glm.Vec3Base, depth: number);
		insert(node: minko.scene.Node): minko.math.OctTree ;
		remove(node: minko.scene.Node): minko.math.OctTree ;
		computeDepth(node: minko.scene.Node): number ;
		generateVisual(assetLibrary: minko.file.AssetLibrary, rootNode?: minko.scene.Node): minko.scene.Node ;
		testFrustum(frustum: minko.math.AbstractShape, insideFrustumCallback: (arg0: minko.scene.Node) => void, outsideFustumCallback: (arg0: minko.scene.Node) => void): void ;
		addToContent(node: minko.scene.Node): void ;
		removeFromContent(node: minko.scene.Node): boolean ;
		addToChildContent(node: minko.scene.Node): void ;
		intersects(node: minko.scene.Node): boolean ;
		findNodeOctant(node: minko.scene.Node): void ;
		nodeModelToWorldChanged(node: minko.scene.Node): void ;
		invalidateNode(node: minko.scene.Node): void ;
		childOctantsIntersection(node: minko.scene.Node, octants: minko.math.OctTree[]): boolean ;
		doInsert(node: minko.scene.Node, currentDepth: number, optimalDepth: number): minko.math.OctTree ;
		doRemove(node: minko.scene.Node): minko.math.OctTree ;
		readonly edgeLength: number;
		static readonly _k: number;
		static create(worldSize: number, maxDepth: number, center: glm.Vec3Base, depth?: number): minko.math.OctTree ;
	}
}

export namespace minko.math {
	class Ray{
		constructor();
		direction: glm.Vec3Base;
		origin: glm.Vec3Base;
		setRay(origin: glm.Vec3Base, direction: glm.Vec3Base): void ;
		static createbyVector3(origin: glm.Vec3Base, direction: glm.Vec3Base): minko.math.Ray ;
		static create(): minko.math.Ray ;
	}
}

export namespace minko.net {
	class HTTPOptions extends minko.file.Options{
		constructor();
		username: string;
		password: string;
		readonly additionalHeaders: minko.Tuple<string, string>[];
		verifyPeer: boolean;
		copyFrom(copy: minko.file.Options): minko.net.HTTPOptions ;
		clone(): minko.file.Options ;
		static create(): minko.net.HTTPOptions ;
		static createbyOptions(copy: minko.file.Options): minko.net.HTTPOptions ;
	}
}

export namespace minko.net {
	class WebHTTPProtocol extends minko.file.AbstractProtocol{
		constructor();
		load(): void ;
		fileExists(filename: string): boolean ;
		isAbsolutePath(filename: string): boolean ;
		static create(): minko.net.WebHTTPProtocol ;
	}
}

export namespace minko.render {
	class AbstractContextFace{
		private constructor();
		static readonly POSITIVE_X: number;
		static readonly NEGATIVE_X: number;
		static readonly POSITIVE_Y: number;
		static readonly NEGATIVE_Y: number;
		static readonly POSITIVE_Z: number;
		static readonly NEGATIVE_Z: number;
	}
}

export namespace minko.render {
	class AbstractContext{
		constructor();
		dispose(): void ;
		errorsEnabled: boolean;
		readonly driverInfo: string;
		readonly renderTarget: number;
		readonly viewportWidth: number;
		readonly viewportHeight: number;
		readonly currentProgram: number;
		configureViewport(x: number, y: number, width: number, height: number): void ;
		clear(red: number, green?: number, blue?: number, alpha?: number, depth?: number, stencil?: number, mask?: number): void ;
		present(): void ;
		drawIndexBufferTriangles(indexBuffer: number, firstIndex: number, numTriangles: number): void ;
		drawTriangles(firstIndex: number, numTriangles: number): void ;
		createVertexBuffer(size: number): number ;
		setVertexBufferAt(position: number, vertexBuffer: number, size: number, stride: number, offset: number): void ;
		uploadVertexBufferData(vertexBuffer: number, offset: number, size: number, data: number[]): void ;
		deleteVertexBuffer(vertexBuffer: number): void ;
		createIndexBuffer(size: number): number ;
		uploaderIndexBufferData(indexBuffer: number, offset: number, size: number, data: number[]): void ;
		deleteIndexBuffer(indexBuffer: number): void ;
		createTexture(type: number, width: number, height: number, mipMapping: boolean, optimizeForRenderToTexture?: boolean, assertPowerOfTwoSized?: boolean): number ;
		createRectangleTexture(type: number, width: number, height: number): number ;
		createCompressedTexture(type: number, format: number, width: number, height: number, mipMapping: boolean): number ;
		uploadTexture2dData(texture: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCubeTextureData(texture: number, face: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCompressedTexture2dData(texture: number, format: number, width: number, height: number, size: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCompressedCubeTextureData(texture: number, face: number, format: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		activateMipMapping(texture: number): void ;
		deleteTexture(texture: number): void ;
		setTextureAt(position: number, texture: number, location?: number): void ;
		setSamplerStateAt(position: number, wrapping: number, filtering: number, mipFiltering: number): void ;
		createProgram(): number ;
		attachShader(program: number, shader: number): void ;
		linkProgram(program: number): void ;
		deleteProgram(program: number): void ;
		setProgram(program: number): void ;
		compileShader(shader: number): void ;
		setShaderSource(shader: number, source: string): void ;
		createVertexShader(): number ;
		deleteVertexShader(vertexShader: number): void ;
		createFragmentShader(): number ;
		deleteFragmentShader(fragmentShader: number): void ;
		getProgramInputs(program: number): minko.render.ProgramInputs ;
		setBlendingModeSD(source: number, destination: number): void ;
		setBlendingMode(blendMode: number): void ;
		setColorMask(NamelessParameter: boolean): void ;
		setDepthTest(depthMask: boolean, depthFunc: number): void ;
		setStencilTest(stencilFunc: number, stencilRef: number, stencilMask: number, stencilFailOp: number, stencilZFailOp: number, stencilZPassOp: number): void ;
		setScissorTest(scissorTest: boolean, NamelessParameter2: glm.Vec4Base): void ;
		readPixels(pixels: haxe.io.Bytes): void ;
		readRectPixels(x: number, y: number, width: number, height: number, pixels: haxe.io.Bytes): void ;
		setTriangleCulling(triangleCulling: number): void ;
		setRenderToBackBuffer(): void ;
		setRenderToTexture(texture: number, enableDepthAndStencil?: boolean): void ;
		generateMipmaps(texture: number): void ;
		setUniformFloat(location: number, count: number, v: number[]): void ;
		setUniformFloat2(location: number, count: number, v: number[]): void ;
		setUniformFloat3(location: number, count: number, v: number[]): void ;
		setUniformFloat4(location: number, count: number, v: number[]): void ;
		setUniformMatrix4x4(location: number, count: number, v: number[]): void ;
		setUniformInt(location: number, count: number, v: number[]): void ;
		setUniformInt2(location: number, count: number, v: number[]): void ;
		setUniformInt3(location: number, count: number, v: number[]): void ;
		setUniformInt4(location: number, count: number, v: number[]): void ;
		createVertexAttributeArray(): number ;
		setVertexAttributeArray(vertexArray: number): void ;
	}
}

export namespace minko.render {
	class AbstractResource{
		constructor(context: minko.render.AbstractContext);
		readonly uuid: string;
		readonly context: minko.render.AbstractContext;
		id: number;
		readonly isReady: boolean;
		dispose(): void ;
		upload(): void ;
	}
}

export namespace minko.render {
	class AbstractTexture extends minko.render.AbstractResource{
		constructor(type: number, context: minko.render.AbstractContext, width: number, height: number, format: number, mipMapping: boolean, optimizeForRenderToTexture: boolean, resizeSmoothly: boolean, filename: string);
		MAX_SIZE: number;
		readonly sampler: minko.render.TextureSampler;
		readonly type: number;
		readonly format: number;
		readonly width: number;
		readonly height: number;
		readonly originalWidth: number;
		readonly originalHeight: number;
		readonly mipMapping: boolean;
		activateMipMapping(): void ;
		readonly optimizeForRenderToTexture: boolean;
		resize(width: number, height: number, resizeSmoothly: boolean): void ;
		disposeData(): void ;
		resizeData(width: number, height: number, data: haxe.io.Bytes, newWidth: number, newHeight: number, resizeSmoothly: boolean): haxe.io.Bytes ;
		getMipmapWidth(level: number): number ;
		getMipmapHeight(level: number): number ;
	}
}

export namespace minko.render {
	class Source{
		private constructor();
		static readonly ZERO: number;
		static readonly ONE: number;
		static readonly SRC_COLOR: number;
		static readonly ONE_MINUS_SRC_COLOR: number;
		static readonly SRC_ALPHA: number;
		static readonly ONE_MINUS_SRC_ALPHA: number;
		static readonly DST_ALPHA: number;
		static readonly ONE_MINUS_DST_ALPHA: number;
	}
}

export namespace minko.render {
	class Destination{
		private constructor();
		static readonly ZERO: number;
		static readonly ONE: number;
		static readonly DST_COLOR: number;
		static readonly ONE_MINUS_DST_COLOR: number;
		static readonly SRC_ALPHA_SATURATE: number;
		static readonly ONE_MINUS_SRC_ALPHA: number;
		static readonly DST_ALPHA: number;
		static readonly ONE_MINUS_DST_ALPHA: number;
	}
}

export namespace minko.render {
	class Mode{
		private constructor();
		static readonly DEFAULT: number;
		static readonly ALPHA: number;
		static readonly ADDITIVE: number;
	}
}

export namespace minko.render {
	class CompareMode{
		private constructor();
		static readonly ALWAYS: number;
		static readonly EQUAL: number;
		static readonly GREATER: number;
		static readonly GREATER_EQUAL: number;
		static readonly LESS: number;
		static readonly LESS_EQUAL: number;
		static readonly NEVER: number;
		static readonly NOT_EQUAL: number;
		static readonly UNSET: number;
	}
}

export namespace minko.render {
	class Face{
		private constructor();
		static readonly POSITIVE_X: number;
		static readonly NEGATIVE_X: number;
		static readonly POSITIVE_Y: number;
		static readonly NEGATIVE_Y: number;
		static readonly POSITIVE_Z: number;
		static readonly NEGATIVE_Z: number;
	}
}

export namespace minko.render {
	class CubeTexture extends minko.render.AbstractTexture{
		constructor(context: minko.render.AbstractContext, width: number, height: number, format?: number, mipMapping?: boolean, optimizeForRenderToTexture?: boolean, resizeSmoothly?: boolean, filename?: string);
		setData(data: haxe.io.Bytes, face: number, widthGPU?: number, heightGPU?: number): void ;
		resize(width: number, height: number, resizeSmoothly: boolean): void ;
		uploadMipLevel(level: number, data: haxe.io.Bytes, face: number): void ;
		upload(): void ;
		dispose(): void ;
		disposeData(): void ;
		static create(context: minko.render.AbstractContext, width: number, height: number, mipMapping?: boolean, optimizeForRenderToTexture?: boolean, resizeSmoothly?: boolean, format?: number, filename?: string): minko.render.CubeTexture ;
	}
}

export namespace minko.render {
	class UniformInput extends minko.render.AbstractInput{
		constructor(name: string, location: number, size: number, type: number);
		type: number;
		size: number;
	}
}

export namespace minko.render {
	class AttributeInput extends minko.render.AbstractInput{
		constructor(name: string, location: number);
	}
}

export namespace minko.render {
	class UniformValue<T>{
		constructor(location: number, size: number, count: number, dataArray: T[]);
		location: number;
		size: number;
		count: number;
		data: any;
		dataArray: T[];
		static vecInts1(dataValue: number): number[] ;
		static vecInts2(dataValue: glm.Vec2Base): number[] ;
		static vecInts3(dataValue: glm.Vec3Base): number[] ;
		static vecInts4(dataValue: glm.Vec4Base): number[] ;
		static vecFloats1(dataValue: number): number[] ;
		static vecFloats2(dataValue: glm.Vec2Base): number[] ;
		static vecFloats3(dataValue: glm.Vec3Base): number[] ;
		static vecFloats4(dataValue: glm.Vec4Base): number[] ;
		static matFloats(dataValue: glm.Mat4Base): number[] ;
		static vecsInts1(dataValue: number[]): number[] ;
		static vecsInts2(dataValue: glm.Vec2Base[]): number[] ;
		static vecsInts3(dataValue: glm.Vec3Base[]): number[] ;
		static vecsInts4(dataValue: glm.Vec4Base[]): number[] ;
		static vecsFloats1(dataValue: number[]): number[] ;
		static vecsFloats2(dataValue: glm.Vec2Base[]): number[] ;
		static vecsFloats3(dataValue: glm.Vec3Base[]): number[] ;
		static vecsFloats4(dataValue: glm.Vec4Base[]): number[] ;
		static matsFloats(dataValue: glm.Mat4Base[]): number[] ;
	}
}

export namespace minko.render {
	class SamplerValue{
		constructor(position: number, sampler: minko.render.TextureSampler, location: number);
		position: number;
		sampler: minko.render.TextureSampler;
		location: number;
		wrapMode: number;
		textureFilter: number;
		mipFilter: number;
	}
}

export namespace minko.render {
	class AttributeValue{
		constructor(location: number, resourceId: number, size: number, vertexSize: number, offset: number);
		location: number;
		resourceId: number;
		size: number;
		stride: number;
		offset: number;
	}
}

export namespace minko.render {
	class DrawCall extends minko.Enable_uuid{
		constructor(batchId: number, pass: minko.render.Pass, variables: minko.Tuple<string, string>[], rootData: minko.data.Store, rendererData: minko.data.Store, targetData: minko.data.Store);
		dispose(): void ;
		enabled: boolean;
		readonly batchIDs: number[];
		readonly pass: minko.render.Pass;
		readonly program: minko.render.Program;
		variables: minko.Tuple<string, string>[];
		readonly rootData: minko.data.Store;
		readonly rendererData: minko.data.Store;
		readonly targetData: minko.data.Store;
		readonly boundBoolUniforms: minko.render.UniformValue<number>[];
		readonly boundIntUniforms: minko.render.UniformValue<number>[];
		readonly boundFloatUniforms: minko.render.UniformValue<number>[];
		readonly samplers: minko.render.SamplerValue[];
		readonly priority: number;
		readonly zSorted: boolean;
		readonly blendingSource: number;
		readonly blendingDestination: number;
		readonly colorMask: boolean;
		readonly depthMask: boolean;
		readonly depthFunction: number;
		readonly triangleCulling: number;
		readonly stencilFunction: number;
		readonly stencilReference: number;
		readonly stencilMask: number;
		readonly stencilFailOperation: number;
		readonly stencilZFailOperation: number;
		readonly stencilZPassOperation: number;
		readonly scissorTest: boolean;
		readonly scissorBox: glm.Vec4Base;
		readonly target: minko.render.Texture;
		readonly numTriangles: number;
		bind(program: minko.render.Program): void ;
		render(context: minko.render.AbstractContext, renderTarget: minko.render.AbstractTexture, viewport: glm.Vec4Base, clearColor: number): void ;
		bindAttribute(input: minko.render.AttributeInput, attributeBindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store): void ;
		bindUniform(input: minko.render.UniformInput, uniformBindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store): minko.data.ResolvedBinding ;
		bindSamplerStates(input: minko.render.UniformInput, uniformBindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store): minko.data.ResolvedBinding[] ;
		bindSamplerState(input: minko.render.UniformInput, uniformBindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store, samplerStateProperty: string): minko.data.ResolvedBinding ;
		bindStates(stateBindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store): minko.data.ResolvedBinding[] ;
		bindState(stateName: string, bindings: haxe.ds.StringMap<minko.data.Binding>, defaultValues: minko.data.Store): minko.data.ResolvedBinding ;
		bindPositionalMembers(): void ;
		bindIndexBuffer(): void ;
		getEyeSpacePosition(): glm.Vec3Base ;
		initializeOnContext(context: minko.render.AbstractContext): void ;
		static readonly MAX_NUM_TEXTURES: number;
		static readonly MAX_NUM_VERTEXBUFFERS: number;
	}
}

export namespace minko.render {
	class DrawCallPool{
		constructor();
		dispose(): void ;
		readonly drawCallsKeys: string[];
		readonly drawCalls: haxe.ds.StringMap<minko.Tuple<minko.render.DrawCall[], minko.render.DrawCall[]>>;
		addDrawCalls(effect: minko.render.Effect, techniqueName: string, variables: minko.Tuple<string, string>[], rootData: minko.data.Store, rendererData: minko.data.Store, targetData: minko.data.Store): number ;
		removeDrawCalls(batchId: number): void ;
		invalidateDrawCalls(batchId: number, variables: minko.Tuple<string, string>[]): void ;
		update(forceSort: boolean, mustZSort?: boolean): void ;
		clear(): void ;
		readonly numDrawCalls: number;
		macroPropertyAddedHandler(macroBinding: minko.data.MacroBinding, propertyName: string, store: minko.data.Store, drawCalls: minko.render.DrawCall[]): void ;
		macroPropertyRemovedHandler(macroBinding: minko.data.MacroBinding, propertyName: string, store: minko.data.Store, drawCalls: minko.render.DrawCall[]): void ;
		macroPropertyChangedHandler(macroBinding: minko.data.MacroBinding, drawCalls: minko.render.DrawCall[]): void ;
		addMacroCallback(key: string, signal: minko.signal.Signal3<minko.data.Store, minko.data.Provider, string>, callback: (arg0: minko.data.Store, arg1: minko.data.Provider, arg2: string) => void): void ;
		removeMacroCallback(key: string): void ;
		hasMacroCallback(key: string): boolean ;
		bindDrawCall(drawCall: minko.render.DrawCall, pass: minko.render.Pass, program: minko.render.Program, forceRebind: boolean): void ;
		static macroBindingKey(propertyName: string, m: minko.data.MacroBinding, s: minko.data.Store): string ;
		static drawCallKey(m: minko.data.Binding, s: minko.render.DrawCall): string ;
		static sortPropertyTuple(m: number, s: number): string ;
	}
}

export namespace minko.render {
	class Effect extends minko.Has_uuid{
		constructor(name: string);
		readonly name: string;
		readonly techniques: haxe.ds.StringMap<minko.render.Pass[]>;
		readonly data: minko.data.Provider;
		technique(techniqueName: string): minko.render.Pass[] ;
		fallback(techniqueName: string): string ;
		hasTechnique(techniqueName: string): boolean ;
		hasFallback(techniqueName: string): boolean ;
		setUniform(name: string, values: any[]): void ;
		setAttribute(name: string, attribute: minko.render.VertexAttribute): void ;
		define(macroName: string): void ;
		setDefine(macroName: string, macroValue: any): void ;
		addTechnique(name: string, passes: minko.render.Pass[]): void ;
		addTechniqueFallback(name: string, passes: minko.render.Pass[], fallback: string): void ;
		removeTechnique(name: string): void ;
		initializeMaterial(material: minko.material.Material, technique?: string): minko.material.Material ;
		static create(name: string): minko.render.Effect ;
		static createbyTechnique(name: string, passes: minko.render.Pass[]): minko.render.Effect ;
	}
}

export namespace minko.render {
	class GlContext extends minko.render.AbstractContext{
		constructor();
		gl: WebGLRenderingContext;
		initialize(): void ;
		dispose(): void ;
		configureViewport(x: number, y: number, width: number, height: number): void ;
		clear(red: number, green?: number, blue?: number, alpha?: number, depth?: number, stencil?: number, mask?: number): void ;
		present(): void ;
		drawTriangles(firstIndex: number, numTriangles: number): void ;
		drawIndexBufferTriangles(indexBuffer: number, firstIndex: number, numTriangles: number): void ;
		createVertexBuffer(size: number): number ;
		createVertexAttributeArray(): number ;
		setVertexAttributeArray(vertexArray: number): void ;
		setVertexBufferAt(position: number, vertexBuffer: number, size: number, stride: number, offset: number): void ;
		uploadVertexBufferData(vertexBuffer: number, offset: number, size: number, data: number[]): void ;
		deleteVertexBuffer(vertexBuffer: number): void ;
		createIndexBuffer(size: number): number ;
		uploaderIndexBufferData(indexBuffer: number, offset: number, size: number, data: number[]): void ;
		deleteIndexBuffer(indexBuffer: number): void ;
		createTexture(type: number, width: number, height: number, mipMapping: boolean, optimizeForRenderToTexture?: boolean, assertPowerOfTwoSized?: boolean): number ;
		createRectangleTexture(type: number, width: number, height: number): number ;
		createCompressedTexture(type: number, format: number, width: number, height: number, mipMapping: boolean): number ;
		getTextureType(textureId: number): number ;
		uploadTexture2dData(texture: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCubeTextureData(texture: number, face: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCompressedTexture2dData(texture: number, format: number, width: number, height: number, size: number, mipLevel: number, data: haxe.io.Bytes): void ;
		uploadCompressedCubeTextureData(texture: number, face: number, format: number, width: number, height: number, mipLevel: number, data: haxe.io.Bytes): void ;
		activateMipMapping(texture: number): void ;
		deleteTexture(texture: number): void ;
		setTextureAt(position: number, texture: number, location?: number): void ;
		setSamplerStateAt(position: number, wrapping: number, filtering: number, mipFiltering: number): void ;
		createProgram(): number ;
		attachShader(program: number, shader: number): void ;
		linkProgram(program: number): void ;
		deleteProgram(program: number): void ;
		compileShader(shader: number): void ;
		setProgram(program: number): void ;
		setShaderSource(shader: number, source: string): void ;
		getShaderSource(shader: number): string ;
		createVertexShader(): number ;
		deleteVertexShader(vertexShader: number): void ;
		createFragmentShader(): number ;
		deleteFragmentShader(fragmentShader: number): void ;
		getProgramInputs(program: number): minko.render.ProgramInputs ;
		convertInputType(type: number): number ;
		getUniformInput(program: number, name: string): minko.render.UniformInput ;
		getAttributeInput(program: number, name: string): minko.render.AttributeInput ;
		getShaderCompilationLogs(shader: number): string ;
		getProgramInfoLogs(program: number): string ;
		setBlendingModeSD(source: number, destination: number): void ;
		setBlendingMode(blendingMode: number): void ;
		setDepthTest(depthMask: boolean, depthFunc: number): void ;
		setColorMask(colorMask: boolean): void ;
		setStencilTest(stencilFunc: number, stencilRef: number, stencilMask: number, stencilFailOp: number, stencilZFailOp: number, stencilZPassOp: number): void ;
		readRectPixels(x: number, y: number, width: number, height: number, pixels: haxe.io.Bytes): void ;
		setScissorTest(scissorTest: boolean, scissorBox: glm.Vec4Base): void ;
		readPixels(pixels: haxe.io.Bytes): void ;
		setTriangleCulling(triangleCulling: number): void ;
		setRenderToBackBuffer(): void ;
		setRenderToTexture(texture: number, enableDepthAndStencil?: boolean): void ;
		getError(): number ;
		generateMipmaps(texture: number): void ;
		setUniformFloat(location: number, count: number, v: number[]): void ;
		setUniformFloat2(location: number, count: number, v: number[]): void ;
		setUniformFloat3(location: number, count: number, v: number[]): void ;
		setUniformFloat4(location: number, count: number, v: number[]): void ;
		setUniformMatrix4x4(location: number, count: number, v: number[]): void ;
		setUniformInt(location: number, count: number, v: number[]): void ;
		setUniformInt2(location: number, count: number, v: number[]): void ;
		setUniformInt3(location: number, count: number, v: number[]): void ;
		setUniformInt4(location: number, count: number, v: number[]): void ;
		supportsExtension(extensionNameString: string): boolean ;
		availableTextureFormats(): haxe.ds.IntMap<number> ;
		static create(): minko.render.GlContext ;
	}
}

export namespace minko.render {
	class IndexBuffer extends minko.render.AbstractResource{
		constructor(context: minko.render.AbstractContext);
		data: number[];
		readonly dataPointer: number[];
		readonly numIndices: number;
		upload(): void ;
		uploadOffset(offset: number, count?: number): void ;
		uploadOffsetData(offset: number, count: number, data: number[]): void ;
		dispose(): void ;
		disposeData(): void ;
		equals(indexBuffer: minko.render.IndexBuffer): boolean ;
		readonly changed: minko.signal.Signal<minko.render.IndexBuffer>;
		static create(context: minko.render.AbstractContext): minko.render.IndexBuffer ;
		static createbyData(context: minko.render.AbstractContext, data: number[]): minko.render.IndexBuffer ;
	}
}

export namespace minko.render {
	class MipFilter{
		private constructor();
		static readonly NONE: number;
		static readonly NEAREST: number;
		static readonly LINEAR: number;
	}
}

export namespace minko.render {
	class Pass{
		constructor(name: string, isForward: boolean, program: minko.render.Program, attributeBindings: minko.data.BindingMapBase<minko.data.Binding>, uniformBindings: minko.data.BindingMapBase<minko.data.Binding>, stateBindings: minko.data.BindingMapBase<minko.data.Binding>, macroBindings: minko.data.MacroBindingMap);
		dispose(): void ;
		readonly name: string;
		readonly isForward: boolean;
		readonly program: minko.render.Program;
		readonly attributeBindings: minko.data.BindingMapBase<minko.data.Binding>;
		readonly uniformBindings: minko.data.BindingMapBase<minko.data.Binding>;
		readonly stateBindings: minko.data.BindingMapBase<minko.data.Binding>;
		readonly macroBindings: minko.data.MacroBindingMap;
		readonly states: minko.render.States;
		setUniform(name: string, values: any[]): void ;
		setAttribute(name: string, attribute: minko.render.VertexAttribute): void ;
		define(macroName: string): void ;
		setDefine(macroName: string, macroValue: any): void ;
		selectProgram(vars: minko.Tuple<string, string>[], targetData: minko.data.Store, rendererData: minko.data.Store, rootData: minko.data.Store): minko.Tuple<minko.render.Program, minko.render.ProgramSignature> ;
		finalizeProgram(program: minko.render.Program): minko.render.Program ;
		static create(name: string, isForward: boolean, program: minko.render.Program, attributeBindings: minko.data.BindingMapBase<minko.data.Binding>, uniformBindings: minko.data.BindingMapBase<minko.data.Binding>, stateBindings: minko.data.BindingMapBase<minko.data.Binding>, macroBindings: minko.data.MacroBindingMap): minko.render.Pass ;
		static createbyPass(pass: minko.render.Pass, deepCopy?: boolean): minko.render.Pass ;
	}
}

export namespace minko.render {
	class Program extends minko.render.AbstractResource{
		constructor(_name: string, context: minko.render.AbstractContext);
		clearDefinedMacros(): void ;
		readonly name: string;
		readonly vertexShader: minko.render.Shader;
		readonly fragmentShader: minko.render.Shader;
		readonly setTextureNames: string[];
		readonly setAttributeNames: string[];
		readonly setUniformNames: string[];
		readonly definedMacroNames: string[];
		readonly inputs: minko.render.ProgramInputs;
		upload(): void ;
		dispose(): void ;
		setUniform(name: string, v: any[]): void ;
		setUniformFloat1(name: string, v: number[]): minko.render.Program ;
		setUniformFloat2(name: string, value: number[]): minko.render.Program ;
		setUniformFloat3(name: string, value: number[]): minko.render.Program ;
		setUniformFloat4(name: string, value: number[]): minko.render.Program ;
		setUniformMatrix4x4(name: string, value: number[]): minko.render.Program ;
		setUniformInt1(name: string, v: number[]): minko.render.Program ;
		setUniformInt2(name: string, value: number[]): minko.render.Program ;
		setUniformInt3(name: string, value: number[]): minko.render.Program ;
		setUniformInt4(name: string, value: number[]): minko.render.Program ;
		setUniformAbstractTexture(name: string, texture: minko.render.AbstractTexture): minko.render.Program ;
		define(macroName: string): minko.render.Program ;
		setDefine(macroName: string, value: string): minko.render.Program ;
		setAttributebyName(name: string, attribute: minko.render.VertexAttribute): minko.render.Program ;
		setAttribute(name: string, attribute: minko.render.VertexAttribute, attributeName: string): minko.render.Program ;
		static create(name: string, context: minko.render.AbstractContext): minko.render.Program ;
		static createbyProgram(program: minko.render.Program, deepCopy?: boolean): minko.render.Program ;
		static createbyShader(name: string, context: minko.render.AbstractContext, vertexShader: minko.render.Shader, fragmentShader: minko.render.Shader): minko.render.Program ;
	}
}

export namespace minko.render {
	class InputType{
		private constructor();
		static readonly unknown: number;
		static readonly int1: number;
		static readonly int2: number;
		static readonly int3: number;
		static readonly int4: number;
		static readonly bool1: number;
		static readonly bool2: number;
		static readonly bool3: number;
		static readonly bool4: number;
		static readonly float1: number;
		static readonly float2: number;
		static readonly float3: number;
		static readonly float4: number;
		static readonly float9: number;
		static readonly float16: number;
		static readonly sampler2d: number;
		static readonly samplerCube: number;
	}
}

export namespace minko.render {
	class AbstractInput{
		constructor(name: string, location: number);
		name: string;
		location: number;
		dispose(): void ;
	}
}

export namespace minko.render {
	class ProgramInputs{
		constructor();
		readonly uniforms: minko.render.UniformInput[];
		readonly attributes: minko.render.AttributeInput[];
		copyFrom(inputs: minko.render.ProgramInputs): minko.render.ProgramInputs ;
		setProgramInputs(uniforms: minko.render.UniformInput[], attributes: minko.render.AttributeInput[]): void ;
		static typeToString(type: number): string ;
	}
}

export namespace minko.render {
	class ProgramSignature{
		constructor();
		readonly key: string;
		bind(macroBindings: minko.data.MacroBindingMap, variables: minko.Tuple<string, string>[], targetData: minko.data.Store, rendererData: minko.data.Store, rootData: minko.data.Store): void ;
		copyFrom(signature: minko.render.ProgramSignature): minko.render.ProgramSignature ;
		updateProgram(program: minko.render.Program): void ;
		getValueFromStore(store: minko.data.Store, propertyName: string, type: number): number ;
		dispose(): void ;
		static readonly _maxNumMacros: number;
	}
}

export namespace minko.render {
	class RectangleTexture extends minko.render.AbstractTexture{
		constructor(context: minko.render.AbstractContext, width: number, height: number, format: number, filename?: string);
		readonly data: haxe.io.Bytes;
		setData(data: haxe.io.Bytes, widthGPU?: number, heightGPU?: number): void ;
		resize(width: number, height: number, resizeSmoothly: boolean): void ;
		dispose(): void ;
		disposeData(): void ;
		upload(): void ;
		static create(context: minko.render.AbstractContext, width: number, height: number, format: number, filename?: string): minko.render.RectangleTexture ;
	}
}

export namespace minko.render {
	class SamplerStates{
		constructor(wm: number, tf: number, mf: number);
		wrapMode: number;
		textureFilter: number;
		mipFilter: number;
		static readonly PROPERTY_WRAP_MODE: string;
		static readonly PROPERTY_TEXTURE_FILTER: string;
		static readonly PROPERTY_MIP_FILTER: string;
		static PROPERTY_NAMES: string[];
		static readonly DEFAULT_WRAP_MODE: number;
		static readonly DEFAULT_TEXTURE_FILTER: number;
		static readonly DEFAULT_MIP_FILTER: number;
		static uniformNameToSamplerStateName(uniformName: string, sampleState: string): string ;
		static uniformNameToSamplerStateBindingName(uniformName: string, samplerState: string): string ;
		static stringToWrapMode(value: string): number ;
		static stringToTextureFilter(value: string): number ;
		static stringToMipFilter(value: string): number ;
	}
}

export namespace minko.render {
	class ShaderType{
		private constructor();
		static readonly VERTEX_SHADER: number;
		static readonly FRAGMENT_SHADER: number;
	}
}

export namespace minko.render {
	class Shader extends minko.render.AbstractResource{
		constructor(context: minko.render.AbstractContext, type: number);
		clearDefinedMacros(): void ;
		readonly type: number;
		source: string;
		define(macroName: string): void ;
		setDefine(macroName: string, value: string): void ;
		dispose(): void ;
		upload(): void ;
		static create(context: minko.render.AbstractContext, type: number): minko.render.Shader ;
		static createbySource(context: minko.render.AbstractContext, type: number, source: string): minko.render.Shader ;
		static createbyShader(shader: minko.render.Shader): minko.render.Shader ;
	}
}

export namespace minko.render {
	class States{
		constructor(priority: number, zSorted?: boolean, blendingSourceFactor?: number, blendingDestinationFactor?: number, colorMask?: boolean, depthMask?: boolean, depthFunction?: number, triangleCulling?: number, stencilFunction?: number, stencilRef?: number, stencilMask?: number, stencilFailOp?: number, stencilZFailOp?: number, stencilZPassOp?: number, scissorTest?: boolean, scissorBox?: glm.Vec4Base, target?: minko.render.Texture);
		copyFrom(states: minko.render.States): minko.render.States ;
		resetDefaultValues(): void ;
		data: minko.data.Provider;
		priority: number;
		zSorted: boolean;
		blendingSourceFactor: number;
		blendingDestinationFactor: number;
		colorMask: boolean;
		depthMask: boolean;
		depthFunction: number;
		triangleCulling: number;
		stencilFunction: number;
		stencilReference: number;
		stencilMask: number;
		stencilFailOperation: number;
		stencilZFailOperation: number;
		stencilZPassOperation: number;
		scissorTest: boolean;
		scissorBox: glm.Vec4Base;
		target: minko.render.AbstractTexture;
		static readonly PROPERTY_PRIORITY: string;
		static readonly PROPERTY_ZSORTED: string;
		static readonly PROPERTY_BLENDING_SOURCE: string;
		static readonly PROPERTY_BLENDING_DESTINATION: string;
		static readonly PROPERTY_COLOR_MASK: string;
		static readonly PROPERTY_DEPTH_MASK: string;
		static readonly PROPERTY_DEPTH_FUNCTION: string;
		static readonly PROPERTY_TRIANGLE_CULLING: string;
		static readonly PROPERTY_STENCIL_FUNCTION: string;
		static readonly PROPERTY_STENCIL_REFERENCE: string;
		static readonly PROPERTY_STENCIL_MASK: string;
		static readonly PROPERTY_STENCIL_FAIL_OPERATION: string;
		static readonly PROPERTY_STENCIL_ZFAIL_OPERATION: string;
		static readonly PROPERTY_STENCIL_ZPASS_OPERATION: string;
		static readonly PROPERTY_SCISSOR_TEST: string;
		static readonly PROPERTY_SCISSOR_BOX: string;
		static readonly PROPERTY_TARGET: string;
		static PROPERTY_NAMES: string[];
		static DEFAULT_PRIORITY: number;
		static readonly DEFAULT_ZSORTED: boolean;
		static readonly DEFAULT_BLENDING_SOURCE: number;
		static readonly DEFAULT_BLENDING_DESTINATION: number;
		static readonly DEFAULT_COLOR_MASK: boolean;
		static readonly DEFAULT_DEPTH_MASK: boolean;
		static readonly DEFAULT_DEPTH_FUNCTION: number;
		static readonly DEFAULT_TRIANGLE_CULLING: number;
		static readonly DEFAULT_STENCIL_FUNCTION: number;
		static readonly DEFAULT_STENCIL_REFERENCE: number;
		static readonly DEFAULT_STENCIL_MASK: number;
		static readonly DEFAULT_STENCIL_FAIL_OPERATION: number;
		static readonly DEFAULT_STENCIL_ZFAIL_OPERATION: number;
		static readonly DEFAULT_STENCIL_ZPASS_OPERATION: number;
		static readonly DEFAULT_SCISSOR_TEST: boolean;
		static DEFAULT_SCISSOR_BOX: glm.Vec4Base;
		static DEFAULT_TARGET: minko.render.Texture;
		static UNSET_PRIORITY_VALUE: number;
		static createbyProvider(a: minko.data.Provider): minko.render.States ;
	}
}

export namespace minko.render {
	class StencilOperation{
		private constructor();
		static readonly KEEP: number;
		static readonly ZERO: number;
		static readonly REPLACE: number;
		static readonly INCR: number;
		static readonly INCR_WRAP: number;
		static readonly DECR: number;
		static readonly DECR_WRAP: number;
		static readonly INVERT: number;
		static readonly UNSET: number;
	}
}

export namespace minko.render {
	class Texture extends minko.render.AbstractTexture{
		constructor(context: minko.render.AbstractContext, width: number, height: number, mipMapping?: boolean, optimizeForRenderToTexture?: boolean, resizeSmoothly?: boolean, format?: number, filename?: string);
		readonly data: haxe.io.Bytes[];
		setData(data: haxe.io.Bytes, widthGPU: number, heightGPU: number): void ;
		resize(width: number, height: number, resizeSmoothly: boolean): void ;
		dispose(): void ;
		disposeData(): void ;
		upload(): void ;
		uploadMipLevel(level: number, data: haxe.io.Bytes): void ;
		static create(context: minko.render.AbstractContext, width: number, height: number, mipMapping?: boolean, optimizeForRenderToTexture?: boolean, resizeSmoothly?: boolean, format?: number, filename?: string): minko.render.Texture ;
	}
}

export namespace minko.render {
	class TextureFilter{
		private constructor();
		static readonly NEAREST: number;
		static readonly LINEAR: number;
	}
}

export namespace minko.render {
	class TextureFormat{
		private constructor();
		static readonly RGB: number;
		static readonly RGBA: number;
		static readonly RGB_DXT1: number;
		static readonly RGBA_DXT1: number;
		static readonly RGBA_DXT3: number;
		static readonly RGBA_DXT5: number;
		static readonly RGB_ETC1: number;
		static readonly RGBA_ETC1: number;
		static readonly RGB_PVRTC1_2BPP: number;
		static readonly RGB_PVRTC1_4BPP: number;
		static readonly RGBA_PVRTC1_2BPP: number;
		static readonly RGBA_PVRTC1_4BPP: number;
		static readonly RGBA_PVRTC2_2BPP: number;
		static readonly RGBA_PVRTC2_4BPP: number;
		static readonly RGB_ATITC: number;
		static readonly RGBA_ATITC: number;
		static readonly RGB_ETC2: number;
		static readonly RGBA_ETC2: number;
	}
}

export namespace minko.render {
	class Entry{
		constructor(name: string, isCompressed: boolean, numBitsPerPixel: number, minimumSize: number, hasAlphaChannel: boolean, hasSeparateAlphaChannel: boolean);
		_name: string;
		_isCompressed: boolean;
		_numBitsPerPixel: number;
		_minimumSize: number;
		_hasAlphaChannel: boolean;
		_hasSeparateAlphaChannel: boolean;
	}
}

export namespace minko.render {
	class TextureFormatInfo{
		private constructor();
		static initializeFormatsMap(): haxe.ds.IntMap<minko.render.Entry> ;
		static isSupported(format: number): boolean ;
		static textureSize(format: number, width: number, height: number): number ;
		static name(format: number): string ;
		static isCompressed(format: number): boolean ;
		static numBitsPerPixel(format: number): number ;
		static minimumSize(format: number): number ;
		static hasAlphaChannel(format: number): boolean ;
		static hasSeparateAlphaChannel(format: number): boolean ;
		static readonly textureFormats: number[];
		static get_textureFormats(): number[] ;
	}
}

export namespace minko.render {
	class TextureSampler{
		constructor(uuid: string, id: number);
		uuid: string;
		id: number;
		mipFilter: number;
		textureFilter: number;
		wrapMode: number;
		copyFrom(rhs: minko.render.TextureSampler): void ;
		equals(rhs: minko.render.TextureSampler): boolean ;
	}
}

export namespace minko.render {
	class TextureType{
		private constructor();
		static readonly Texture2D: number;
		static readonly CubeTexture: number;
	}
}

export namespace minko.render {
	class TriangleCulling{
		private constructor();
		static readonly NONE: number;
		static readonly FRONT: number;
		static readonly BACK: number;
		static readonly BOTH: number;
	}
}

export namespace minko.render {
	class VertexAttribute{
		constructor(_id: number, _vertexSize: number, name: string, size: number, actualOffset: number);
		resourceId: number;
		vertexSize: number;
		name: string;
		size: number;
		offset: number;
		equals(rhs: minko.render.VertexAttribute): boolean ;
	}
}

export namespace minko.render {
	class VertexBuffer extends minko.render.AbstractResource{
		constructor(context: minko.render.AbstractContext);
		data: number[];
		readonly attributes: minko.render.VertexAttribute[];
		vertexSize: number;
		readonly vertexSizeChanged: minko.signal.Signal2<minko.render.VertexBuffer, number>;
		readonly numVertices: number;
		upload(): void ;
		uploadOffset(offset: number, numVertices?: number): void ;
		uploadData(offset: number, numVertices: number, data: number[]): void ;
		dispose(): void ;
		disposeData(): void ;
		addAttribute(name: string, size: number, offset?: number): void ;
		removeAttribute(attributeName: string): void ;
		hasAttribute(attributeName: string): boolean ;
		attribute(attributeName: string): minko.render.VertexAttribute ;
		equals(vertexBuffer: minko.render.VertexBuffer): boolean ;
		static create(context: minko.render.AbstractContext): minko.render.VertexBuffer ;
		static createbyVec3Data(context: minko.render.AbstractContext, data: glm.Vec3Base[], len: number): minko.render.VertexBuffer ;
		static createbyData(context: minko.render.AbstractContext, data: number[]): minko.render.VertexBuffer ;
	}
}

export namespace minko.render {
	class WrapMode{
		private constructor();
		static readonly CLAMP: number;
		static readonly REPEAT: number;
	}
}

export namespace minko.scene {
	class BuiltinLayout{
		private constructor();
		static readonly DEFAULT: number;
		static readonly DEBUG_ONLY: number;
		static readonly STATIC: number;
		static readonly IGNORE_RAYCASTING: number;
		static readonly IGNORE_CULLING: number;
		static readonly HIDDEN: number;
		static readonly PICKING: number;
		static readonly INSIDE_FRUSTUM: number;
		static readonly MINOR_OBJECT: number;
		static readonly PICKING_DEPTH: number;
		static readonly CAST_SHADOW: number;
	}
}

export namespace minko.scene {
	class LayoutMask{
		private constructor();
		static readonly NOTHING: number;
		static readonly COLLISIONS_DYNAMIC_DEFAULT: number;
		static readonly EVERYTHING: number;
	}
}

export namespace minko.scene {
	class Node extends minko.Enable_uuid{
		constructor(n: string);
		clone(option: number): minko.scene.Node ;
		cloneNode(): minko.scene.Node ;
		listItems(clonedRoot: minko.scene.Node, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, components: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>): void ;
		rebindComponentsDependencies(componentsMap: haxe.ds.ObjectMap<minko.component.AbstractComponent, minko.component.AbstractComponent>, nodeMap: haxe.ds.ObjectMap<minko.scene.Node, minko.scene.Node>, option: number): void ;
		name: string;
		get_name(): string ;
		set_name(v: string): string ;
		layout: number;
		get_layout(): number ;
		set_layout(v: number): number ;
		readonly parent: minko.scene.Node;
		readonly root: minko.scene.Node;
		readonly children: minko.scene.Node[];
		readonly data: minko.data.Store;
		readonly added: minko.signal.Signal3<minko.scene.Node, minko.scene.Node, minko.scene.Node>;
		readonly removed: minko.signal.Signal3<minko.scene.Node, minko.scene.Node, minko.scene.Node>;
		readonly layoutChanged: minko.signal.Signal2<minko.scene.Node, minko.scene.Node>;
		readonly componentAdded: minko.signal.Signal3<minko.scene.Node, minko.scene.Node, minko.component.AbstractComponent>;
		readonly componentRemoved: minko.signal.Signal3<minko.scene.Node, minko.scene.Node, minko.component.AbstractComponent>;
		addChild(child: minko.scene.Node): minko.scene.Node ;
		removeChild(child: minko.scene.Node): minko.scene.Node ;
		removeChildren(): minko.scene.Node ;
		contains(node: minko.scene.Node): boolean ;
		addComponent(component: minko.component.AbstractComponent): minko.scene.Node ;
		removeComponent(component: minko.component.AbstractComponent): minko.scene.Node ;
		existsComponent(c: minko.component.AbstractComponent): boolean ;
		hasComponent(cClass: any): boolean ;
		getComponent(cClass: any): minko.component.AbstractComponent ;
		getComponents(cClass: any): minko.component.AbstractComponent[] ;
		readonly components: minko.component.AbstractComponent[];
		setNode(uuid: string, name: string): void ;
		updateRoot(): void ;
		dispose(): void ;
		static create(n: string): minko.scene.Node ;
		static createbyLayout(n: string, l: number): minko.scene.Node ;
	}
}

export namespace minko.scene {
	class NodeSet extends minko.scene.Node{
		constructor();
		readonly nodes: minko.scene.Node[];
		dispose(): void ;
		size(): number ;
		descendants(andSelf: boolean, depthFirst?: boolean, result?: minko.scene.NodeSet): minko.scene.NodeSet ;
		ancestors(andSelf: boolean, result?: minko.scene.NodeSet): minko.scene.NodeSet ;
		childrens(andSelf: boolean, result: minko.scene.NodeSet): minko.scene.NodeSet ;
		where(filter: (arg0: minko.scene.Node) => boolean, result?: minko.scene.NodeSet): minko.scene.NodeSet ;
		roots(result: minko.scene.NodeSet): minko.scene.NodeSet ;
		static createbyArray(nodes: minko.scene.Node[]): minko.scene.NodeSet ;
		static create(): minko.scene.NodeSet ;
		static createbyNode(node: minko.scene.Node): minko.scene.NodeSet ;
	}
}

export namespace minko.signal {
	class SignalSlot<A>{
		constructor(_s: minko.signal.Signal<A>);
		_signal: minko.signal.Signal<A>;
		callback: (arg0: A) => void;
		expired: boolean;
		once: boolean;
		disconnect(): void ;
		dispose(): void ;
	}
}

export namespace minko.signal {
	class Signal<A>{
		constructor();
		readonly numCallbacks: number;
		copyFrom(other: minko.signal.Signal<A>): minko.signal.Signal<A> ;
		dispose(): void ;
		connect(callback: (arg0: A) => void, priority?: number, once?: boolean): minko.signal.SignalSlot<A> ;
		execute(a: A): void ;
		remove(it: minko.signal.SignalSlot<A>): void ;
		static create<A>(): minko.signal.Signal<A> ;
	}
}

export namespace minko.signal {
	class SignalSlot2<A, B>{
		constructor(_s: minko.signal.Signal2<A, B>);
		_signal: minko.signal.Signal2<A, B>;
		callback: (arg0: A, arg1: B) => void;
		expired: boolean;
		once: boolean;
		disconnect(): void ;
		dispose(): void ;
	}
}

export namespace minko.signal {
	class Signal2<A, B>{
		constructor();
		_callbacks: minko.Tuple<number, minko.signal.SignalSlot2<A, B>>[];
		readonly numCallbacks: number;
		copyFrom(other: minko.signal.Signal2<A, B>): minko.signal.Signal2<A, B> ;
		dispose(): void ;
		connect(callback: (arg0: A, arg1: B) => void, priority?: number, once?: boolean): minko.signal.SignalSlot2<A, B> ;
		remove(it: minko.signal.SignalSlot2<A, B>): void ;
		execute(a: A, b: B): void ;
		static create<A, B>(): minko.signal.Signal2<A, B> ;
	}
}

export namespace minko.signal {
	class SignalSlot3<A, B, C>{
		constructor(_s: minko.signal.Signal3<A, B, C>);
		_signal: minko.signal.Signal3<A, B, C>;
		callback: (arg0: A, arg1: B, arg2: C) => void;
		expired: boolean;
		once: boolean;
		disconnect(): void ;
		dispose(): void ;
	}
}

export namespace minko.signal {
	class Signal3<A, B, C>{
		constructor();
		readonly numCallbacks: number;
		copyFrom(other: minko.signal.Signal3<A, B, C>): minko.signal.Signal3<A, B, C> ;
		dispose(): void ;
		connect(callback: (arg0: A, arg1: B, arg2: C) => void, priority?: number, once?: boolean): minko.signal.SignalSlot3<A, B, C> ;
		execute(a: A, b: B, c: C): void ;
		remove(it: minko.signal.SignalSlot3<A, B, C>): void ;
		static create<A, B, C>(): minko.signal.Signal3<A, B, C> ;
	}
}

export namespace minko.signal {
	class SignalSlot4<A, B, C, D>{
		constructor(_s: minko.signal.Signal4<A, B, C, D>);
		_signal: minko.signal.Signal4<A, B, C, D>;
		callback: (arg0: A, arg1: B, arg2: C, arg3: D) => void;
		expired: boolean;
		once: boolean;
		disconnect(): void ;
		dispose(): void ;
	}
}

export namespace minko.signal {
	class Signal4<A, B, C, D>{
		constructor();
		_callbacks: minko.Tuple<number, minko.signal.SignalSlot4<A, B, C, D>>[];
		readonly numCallbacks: number;
		copyFrom(other: minko.signal.Signal4<A, B, C, D>): minko.signal.Signal4<A, B, C, D> ;
		dispose(): void ;
		connect(callback: (arg0: A, arg1: B, arg2: C, arg3: D) => void, priority?: number, once?: boolean): minko.signal.SignalSlot4<A, B, C, D> ;
		execute(a: A, b: B, c: C, d: D): void ;
		remove(it: minko.signal.SignalSlot4<A, B, C, D>): void ;
		static create<A, B, C, D>(): minko.signal.Signal4<A, B, C, D> ;
	}
}

export namespace minko.signal {
	class SignalSlot5<A, B, C, D, E>{
		constructor(_s: minko.signal.Signal5<A, B, C, D, E>);
		_signal: minko.signal.Signal5<A, B, C, D, E>;
		callback: (arg0: A, arg1: B, arg2: C, arg3: D, arg4: E) => void;
		expired: boolean;
		once: boolean;
		disconnect(): void ;
		dispose(): void ;
	}
}

export namespace minko.signal {
	class Signal5<A, B, C, D, E>{
		constructor();
		_callbacks: minko.Tuple<number, minko.signal.SignalSlot5<A, B, C, D, E>>[];
		readonly numCallbacks: number;
		copyFrom(other: minko.signal.Signal5<A, B, C, D, E>): minko.signal.Signal5<A, B, C, D, E> ;
		dispose(): void ;
		connect(callback: (arg0: A, arg1: B, arg2: C, arg3: D, arg4: E) => void, priority?: number, once?: boolean): minko.signal.SignalSlot5<A, B, C, D, E> ;
		execute(a: A, b: B, c: C, d: D, e: E): void ;
		remove(it2: minko.signal.SignalSlot5<A, B, C, D, E>): void ;
		static create<A, B, C, D, E>(): minko.signal.Signal5<A, B, C, D, E> ;
	}
}